"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./lib/courses.ts":
/*!************************!*\
  !*** ./lib/courses.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getCourseById: function() { return /* binding */ getCourseById; },\n/* harmony export */   getCoursesByTag: function() { return /* binding */ getCoursesByTag; },\n/* harmony export */   getFeaturedCourses: function() { return /* binding */ getFeaturedCourses; },\n/* harmony export */   testDatabaseConnection: function() { return /* binding */ testDatabaseConnection; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n/**\n * Transform database course row to Course object\n */ function transformCourse(row) {\n    // Handle both 'course_type' and 'type' column names if needed\n    const courseType = row.course_type || null;\n    var _row_signup_enabled, _row_is_featured;\n    return {\n        id: String(row.id || \"\"),\n        title: String(row.title || \"\"),\n        description: String(row.description || \"\"),\n        headline: row.headline || null,\n        bullet_points: Array.isArray(row.bullet_points) ? row.bullet_points : null,\n        provider: row.provider || null,\n        level: row.level || \"Beginner\",\n        duration: String(row.duration || \"\"),\n        tags: row.tag ? [\n            row.tag\n        ] : [],\n        external_url: row.external_url || null,\n        priority: Number(row.priority) || 999,\n        rating: row.rating ? Number(row.rating) : null,\n        reviews: row.reviews ? Number(row.reviews) : null,\n        course_type: courseType,\n        key_skills: row.key_skills || null,\n        modules: row.modules || null,\n        instructors: row.instructors || null,\n        effort: row.effort || null,\n        languages: row.languages || null,\n        price: row.free_trial || undefined,\n        source: String(row.source || \"\"),\n        signup_enabled: Boolean((_row_signup_enabled = row.signup_enabled) !== null && _row_signup_enabled !== void 0 ? _row_signup_enabled : true),\n        is_featured: Boolean((_row_is_featured = row.is_featured) !== null && _row_is_featured !== void 0 ? _row_is_featured : false),\n        price_label: row.price_label || null,\n        free_trial: row.free_trial || null,\n        created_at: row.created_at || null,\n        updated_at: row.updated_at || null\n    };\n}\n/**\n * Fetches courses filtered by tag, ordered by priority ascending\n */ async function getCoursesByTag(tag) {\n    try {\n        console.log(\"Fetching courses with tag: \".concat(tag));\n        const { data: courses, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag).order(\"priority\", {\n            ascending: true,\n            nullsFirst: true\n        });\n        if (error) {\n            console.error(\"Error fetching courses by tag:\", error);\n            console.error(\"Error details:\", JSON.stringify(error, null, 2));\n            throw error;\n        }\n        console.log(\"Found \".concat((courses === null || courses === void 0 ? void 0 : courses.length) || 0, \" courses with tag \").concat(tag));\n        if (courses && courses.length > 0) {\n            console.log(\"Sample course:\", JSON.stringify(courses[0], null, 2));\n        }\n        return (courses || []).map(transformCourse);\n    } catch (error) {\n        console.error(\"Error in getCoursesByTag:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches a single course by ID\n * Uses maybeSingle() to handle not found gracefully\n */ async function getCourseById(id) {\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"id\", id).maybeSingle();\n        if (error) {\n            console.error(\"Error fetching course by ID:\", error);\n            throw error;\n        }\n        if (!data) {\n            return null;\n        }\n        return transformCourse(data);\n    } catch (error) {\n        console.error(\"Error in getCourseById:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches all courses ordered by priority ascending\n */ async function getAllCourses() {\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").order(\"priority\", {\n            ascending: true,\n            nullsFirst: false\n        });\n        if (error) {\n            console.error(\"Error fetching all courses:\", error);\n            throw error;\n        }\n        return (data || []).map(transformCourse);\n    } catch (error) {\n        console.error(\"Error in getAllCourses:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches top courses (by priority) - if is_featured doesn't exist, \n * we'll use priority <= 3 as featured\n */ async function getFeaturedCourses() {\n    try {\n        // Get top courses ordered by priority\n        const { data: courses, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").order(\"priority\", {\n            ascending: true,\n            nullsFirst: true\n        }).limit(20) // Get top 20, then filter\n        ;\n        if (error) {\n            console.error(\"Error fetching featured courses:\", error);\n            throw error;\n        }\n        // Transform and filter to top 3 by priority\n        const transformed = (courses || []).map(transformCourse);\n        const filtered = transformed.filter((c)=>c.priority !== null && c.priority <= 3).slice(0, 3);\n        console.log(\"Found \".concat(filtered.length, \" featured courses (from \").concat(transformed.length, \" total)\"));\n        return filtered;\n    } catch (error) {\n        console.error(\"Error in getFeaturedCourses:\", error);\n        throw error;\n    }\n}\n/**\n * Test function to check database connection and see what data exists\n */ async function testDatabaseConnection() {\n    try {\n        console.log(\"Testing database connection...\");\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"tag, priority, title\").limit(5);\n        if (error) {\n            console.error(\"Database connection error:\", error);\n            return;\n        }\n        console.log(\"Found \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses in database\"));\n        if (data && data.length > 0) {\n            console.log(\"Sample courses:\", data);\n            const uniqueTags = [\n                ...new Set(data.map((c)=>c.tag).filter(Boolean))\n            ];\n            console.log(\"Unique tags found:\", uniqueTags);\n        }\n    } catch (error) {\n        console.error(\"Error testing database:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUlYLFFBQVFBLEtBQUtXLE1BQU0sR0FBRyxHQUFHO1lBQzNCYixRQUFRQyxHQUFHLENBQUMsbUJBQW1CQztZQUMvQixNQUFNd0IsYUFBYTttQkFBSSxJQUFJQyxJQUFJekIsS0FBS1ksR0FBRyxDQUFDUyxDQUFBQSxJQUFLQSxFQUFFN0MsR0FBRyxFQUFFNEMsTUFBTSxDQUFDNUI7YUFBVTtZQUNyRU0sUUFBUUMsR0FBRyxDQUFDLHNCQUFzQnlCO1FBQ3BDO0lBQ0YsRUFBRSxPQUFPdEIsT0FBTztRQUNkSixRQUFRSSxLQUFLLENBQUMsMkJBQTJCQTtJQUMzQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jb3Vyc2VzLnRzP2U3MWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICcuL3N1cGFiYXNlJ1xuaW1wb3J0IHsgQ291cnNlLCBDb3Vyc2VUYWcsIERhdGFiYXNlQ291cnNlIH0gZnJvbSAnQC90eXBlcy9jb3Vyc2UnXG5cbi8qKlxuICogVHJhbnNmb3JtIGRhdGFiYXNlIGNvdXJzZSByb3cgdG8gQ291cnNlIG9iamVjdFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Db3Vyc2Uocm93OiBEYXRhYmFzZUNvdXJzZSk6IENvdXJzZSB7XG4gIC8vIEhhbmRsZSBib3RoICdjb3Vyc2VfdHlwZScgYW5kICd0eXBlJyBjb2x1bW4gbmFtZXMgaWYgbmVlZGVkXG4gIGNvbnN0IGNvdXJzZVR5cGUgPSByb3cuY291cnNlX3R5cGUgfHwgbnVsbFxuICBcbiAgcmV0dXJuIHtcbiAgICBpZDogU3RyaW5nKHJvdy5pZCB8fCAnJyksXG4gICAgdGl0bGU6IFN0cmluZyhyb3cudGl0bGUgfHwgJycpLFxuICAgIGRlc2NyaXB0aW9uOiBTdHJpbmcocm93LmRlc2NyaXB0aW9uIHx8ICcnKSxcbiAgICBoZWFkbGluZTogcm93LmhlYWRsaW5lIHx8IG51bGwsXG4gICAgYnVsbGV0X3BvaW50czogQXJyYXkuaXNBcnJheShyb3cuYnVsbGV0X3BvaW50cykgPyByb3cuYnVsbGV0X3BvaW50cyA6IG51bGwsXG4gICAgcHJvdmlkZXI6IHJvdy5wcm92aWRlciB8fCBudWxsLFxuICAgIGxldmVsOiAocm93LmxldmVsIGFzIGFueSkgfHwgJ0JlZ2lubmVyJyxcbiAgICBkdXJhdGlvbjogU3RyaW5nKHJvdy5kdXJhdGlvbiB8fCAnJyksXG4gICAgdGFnczogcm93LnRhZyA/IFtyb3cudGFnXSA6IFtdLFxuICAgIGV4dGVybmFsX3VybDogcm93LmV4dGVybmFsX3VybCB8fCBudWxsLFxuICAgIHByaW9yaXR5OiBOdW1iZXIocm93LnByaW9yaXR5KSB8fCA5OTksXG4gICAgcmF0aW5nOiByb3cucmF0aW5nID8gTnVtYmVyKHJvdy5yYXRpbmcpIDogbnVsbCxcbiAgICByZXZpZXdzOiByb3cucmV2aWV3cyA/IE51bWJlcihyb3cucmV2aWV3cykgOiBudWxsLFxuICAgIGNvdXJzZV90eXBlOiBjb3Vyc2VUeXBlLFxuICAgIGtleV9za2lsbHM6IHJvdy5rZXlfc2tpbGxzIHx8IG51bGwsXG4gICAgbW9kdWxlczogcm93Lm1vZHVsZXMgfHwgbnVsbCxcbiAgICBpbnN0cnVjdG9yczogcm93Lmluc3RydWN0b3JzIHx8IG51bGwsXG4gICAgZWZmb3J0OiByb3cuZWZmb3J0IHx8IG51bGwsXG4gICAgbGFuZ3VhZ2VzOiByb3cubGFuZ3VhZ2VzIHx8IG51bGwsXG4gICAgcHJpY2U6IHJvdy5mcmVlX3RyaWFsIHx8IHVuZGVmaW5lZCxcbiAgICBzb3VyY2U6IFN0cmluZyhyb3cuc291cmNlIHx8ICcnKSxcbiAgICBzaWdudXBfZW5hYmxlZDogQm9vbGVhbihyb3cuc2lnbnVwX2VuYWJsZWQgPz8gdHJ1ZSksXG4gICAgaXNfZmVhdHVyZWQ6IEJvb2xlYW4ocm93LmlzX2ZlYXR1cmVkID8/IGZhbHNlKSxcbiAgICBwcmljZV9sYWJlbDogcm93LnByaWNlX2xhYmVsIHx8IG51bGwsXG4gICAgZnJlZV90cmlhbDogcm93LmZyZWVfdHJpYWwgfHwgbnVsbCxcbiAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCB8fCBudWxsLFxuICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0IHx8IG51bGwsXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIGNvdXJzZXMgZmlsdGVyZWQgYnkgdGFnLCBvcmRlcmVkIGJ5IHByaW9yaXR5IGFzY2VuZGluZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlc0J5VGFnKHRhZzogQ291cnNlVGFnKTogUHJvbWlzZTxDb3Vyc2VbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBjb3Vyc2VzIHdpdGggdGFnOiAke3RhZ31gKVxuICAgIGNvbnN0IHsgZGF0YTogY291cnNlcywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgICAgLm9yZGVyKCdwcmlvcml0eScsIHsgYXNjZW5kaW5nOiB0cnVlLCBudWxsc0ZpcnN0OiB0cnVlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvdXJzZXMgYnkgdGFnOicsIGVycm9yKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2NvdXJzZXM/Lmxlbmd0aCB8fCAwfSBjb3Vyc2VzIHdpdGggdGFnICR7dGFnfWApXG4gICAgaWYgKGNvdXJzZXMgJiYgY291cnNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnU2FtcGxlIGNvdXJzZTonLCBKU09OLnN0cmluZ2lmeShjb3Vyc2VzWzBdLCBudWxsLCAyKSlcbiAgICB9XG5cbiAgICByZXR1cm4gKGNvdXJzZXMgfHwgW10pLm1hcCh0cmFuc2Zvcm1Db3Vyc2UpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0Q291cnNlc0J5VGFnOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIGEgc2luZ2xlIGNvdXJzZSBieSBJRFxuICogVXNlcyBtYXliZVNpbmdsZSgpIHRvIGhhbmRsZSBub3QgZm91bmQgZ3JhY2VmdWxseVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxDb3Vyc2UgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLm1heWJlU2luZ2xlKClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY291cnNlIGJ5IElEOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybUNvdXJzZShkYXRhIGFzIERhdGFiYXNlQ291cnNlKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENvdXJzZUJ5SWQ6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoZXMgYWxsIGNvdXJzZXMgb3JkZXJlZCBieSBwcmlvcml0eSBhc2NlbmRpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbENvdXJzZXMoKTogUHJvbWlzZTxDb3Vyc2VbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5vcmRlcigncHJpb3JpdHknLCB7IGFzY2VuZGluZzogdHJ1ZSwgbnVsbHNGaXJzdDogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWxsIGNvdXJzZXM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiAoZGF0YSB8fCBbXSkubWFwKHRyYW5zZm9ybUNvdXJzZSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRBbGxDb3Vyc2VzOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIHRvcCBjb3Vyc2VzIChieSBwcmlvcml0eSkgLSBpZiBpc19mZWF0dXJlZCBkb2Vzbid0IGV4aXN0LCBcbiAqIHdlJ2xsIHVzZSBwcmlvcml0eSA8PSAzIGFzIGZlYXR1cmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRGZWF0dXJlZENvdXJzZXMoKTogUHJvbWlzZTxDb3Vyc2VbXT4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0b3AgY291cnNlcyBvcmRlcmVkIGJ5IHByaW9yaXR5XG4gICAgY29uc3QgeyBkYXRhOiBjb3Vyc2VzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLm9yZGVyKCdwcmlvcml0eScsIHsgYXNjZW5kaW5nOiB0cnVlLCBudWxsc0ZpcnN0OiB0cnVlIH0pXG4gICAgICAubGltaXQoMjApIC8vIEdldCB0b3AgMjAsIHRoZW4gZmlsdGVyXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZlYXR1cmVkIGNvdXJzZXM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBhbmQgZmlsdGVyIHRvIHRvcCAzIGJ5IHByaW9yaXR5XG4gICAgY29uc3QgdHJhbnNmb3JtZWQgPSAoY291cnNlcyB8fCBbXSkubWFwKHRyYW5zZm9ybUNvdXJzZSlcbiAgICBjb25zdCBmaWx0ZXJlZCA9IHRyYW5zZm9ybWVkLmZpbHRlcihjID0+IGMucHJpb3JpdHkgIT09IG51bGwgJiYgYy5wcmlvcml0eSA8PSAzKS5zbGljZSgwLCAzKVxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gZmVhdHVyZWQgY291cnNlcyAoZnJvbSAke3RyYW5zZm9ybWVkLmxlbmd0aH0gdG90YWwpYClcbiAgICByZXR1cm4gZmlsdGVyZWRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRGZWF0dXJlZENvdXJzZXM6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIFRlc3QgZnVuY3Rpb24gdG8gY2hlY2sgZGF0YWJhc2UgY29ubmVjdGlvbiBhbmQgc2VlIHdoYXQgZGF0YSBleGlzdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3REYXRhYmFzZUNvbm5lY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1Rlc3RpbmcgZGF0YWJhc2UgY29ubmVjdGlvbi4uLicpXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJ3RhZywgcHJpb3JpdHksIHRpdGxlJylcbiAgICAgIC5saW1pdCg1KVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7ZGF0YT8ubGVuZ3RoIHx8IDB9IGNvdXJzZXMgaW4gZGF0YWJhc2VgKVxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1NhbXBsZSBjb3Vyc2VzOicsIGRhdGEpXG4gICAgICBjb25zdCB1bmlxdWVUYWdzID0gWy4uLm5ldyBTZXQoZGF0YS5tYXAoYyA9PiBjLnRhZykuZmlsdGVyKEJvb2xlYW4pKV1cbiAgICAgIGNvbnNvbGUubG9nKCdVbmlxdWUgdGFncyBmb3VuZDonLCB1bmlxdWVUYWdzKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0ZXN0aW5nIGRhdGFiYXNlOicsIGVycm9yKVxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInRyYW5zZm9ybUNvdXJzZSIsInJvdyIsImNvdXJzZVR5cGUiLCJjb3Vyc2VfdHlwZSIsImlkIiwiU3RyaW5nIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImhlYWRsaW5lIiwiYnVsbGV0X3BvaW50cyIsIkFycmF5IiwiaXNBcnJheSIsInByb3ZpZGVyIiwibGV2ZWwiLCJkdXJhdGlvbiIsInRhZ3MiLCJ0YWciLCJleHRlcm5hbF91cmwiLCJwcmlvcml0eSIsIk51bWJlciIsInJhdGluZyIsInJldmlld3MiLCJrZXlfc2tpbGxzIiwibW9kdWxlcyIsImluc3RydWN0b3JzIiwiZWZmb3J0IiwibGFuZ3VhZ2VzIiwicHJpY2UiLCJmcmVlX3RyaWFsIiwidW5kZWZpbmVkIiwic291cmNlIiwic2lnbnVwX2VuYWJsZWQiLCJCb29sZWFuIiwiaXNfZmVhdHVyZWQiLCJwcmljZV9sYWJlbCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwiZ2V0Q291cnNlc0J5VGFnIiwiY29uc29sZSIsImxvZyIsImRhdGEiLCJjb3Vyc2VzIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJvcmRlciIsImFzY2VuZGluZyIsIm51bGxzRmlyc3QiLCJKU09OIiwic3RyaW5naWZ5IiwibGVuZ3RoIiwibWFwIiwiZ2V0Q291cnNlQnlJZCIsIm1heWJlU2luZ2xlIiwiZ2V0QWxsQ291cnNlcyIsImdldEZlYXR1cmVkQ291cnNlcyIsImxpbWl0IiwidHJhbnNmb3JtZWQiLCJmaWx0ZXJlZCIsImZpbHRlciIsImMiLCJzbGljZSIsInRlc3REYXRhYmFzZUNvbm5lY3Rpb24iLCJ1bmlxdWVUYWdzIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/courses.ts\n"));

/***/ })

});