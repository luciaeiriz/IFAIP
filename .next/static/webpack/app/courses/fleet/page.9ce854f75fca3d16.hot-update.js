"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/courses/fleet/page",{

/***/ "(app-pages-browser)/./src/data/courses.ts":
/*!*****************************!*\
  !*** ./src/data/courses.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getCourseById: function() { return /* binding */ getCourseById; },\n/* harmony export */   getCoursesByTag: function() { return /* binding */ getCoursesByTag; },\n/* harmony export */   getCoursesByTagForManagement: function() { return /* binding */ getCoursesByTagForManagement; },\n/* harmony export */   getCoursesByTagWithRelevancy: function() { return /* binding */ getCoursesByTagWithRelevancy; },\n/* harmony export */   getFeaturedCourses: function() { return /* binding */ getFeaturedCourses; },\n/* harmony export */   getRelevancyColumn: function() { return /* binding */ getRelevancyColumn; },\n/* harmony export */   testSupabaseConnection: function() { return /* binding */ testSupabaseConnection; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n/**\n * Transform function - handles both 'course_type' and 'type' column names\n */ function transformCourse(row) {\n    // Handle both 'course_type' and 'type' column names\n    const courseType = row.type || row.course_type || null;\n    var _row_signup_enabled, _row_is_featured;\n    return {\n        id: String(row.id || \"\"),\n        title: String(row.title || \"\"),\n        description: String(row.description || \"\"),\n        headline: row.headline || null,\n        bullet_points: Array.isArray(row.bullet_points) ? row.bullet_points : null,\n        provider: row.provider || null,\n        level: row.level || \"Beginner\",\n        duration: String(row.duration || \"\"),\n        tags: row.tag ? [\n            row.tag\n        ] : [],\n        external_url: row.external_url || null,\n        priority: Number(row.priority) || 999,\n        rating: row.rating ? Number(row.rating) : null,\n        reviews: row.reviews ? Number(row.reviews) : null,\n        course_type: courseType,\n        key_skills: row.key_skills || null,\n        modules: row.modules || null,\n        instructors: row.instructors || null,\n        effort: row.effort || null,\n        languages: row.languages || null,\n        price: row.free_trial || undefined,\n        source: String(row.source || \"\"),\n        signup_enabled: Boolean((_row_signup_enabled = row.signup_enabled) !== null && _row_signup_enabled !== void 0 ? _row_signup_enabled : true),\n        is_featured: Boolean((_row_is_featured = row.is_featured) !== null && _row_is_featured !== void 0 ? _row_is_featured : false),\n        price_label: row.price_label || null,\n        free_trial: row.free_trial || null,\n        created_at: row.created_at || null,\n        updated_at: row.updated_at || null\n    };\n}\n/**\n * Raw query - just get everything, no filters\n */ async function rawQueryAllCourses() {\n    try {\n        console.log(\"\\uD83D\\uDD0D RAW QUERY: Fetching ALL courses with no filters...\");\n        // Log the Supabase URL being used (first 30 chars for security)\n        const supabaseUrl = \"https://ktqjebihzkbhsvbqpbui.supabase.co\" || 0;\n        console.log(\"\\uD83D\\uDD17 Supabase URL:\", supabaseUrl ? supabaseUrl.substring(0, 30) + \"...\" : \"❌ MISSING\");\n        console.log(\"\\uD83D\\uDD11 Anon Key:\",  true ? \"✅ Set\" : 0);\n        // Try the simplest possible query first\n        const { data, error, count } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\", {\n            count: \"exact\"\n        }).limit(100) // Add explicit limit\n        ;\n        if (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ RAW QUERY ERROR:\", error);\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            console.error(\"Error hint:\", error.hint);\n            console.error(\"Full error:\", JSON.stringify(error, null, 2));\n            // If it's an RLS error, provide helpful message\n            if (error.code === \"PGRST301\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"permission\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"policy\"))) {\n                console.error(\"\\uD83D\\uDD12 RLS ERROR: Row Level Security is blocking the query!\");\n                console.error(\"Check your Supabase RLS policies for the courses table.\");\n                console.error(\"Go to Supabase Dashboard → Authentication → Policies → courses table\");\n                console.error('Make sure \"courses_select_public\" policy exists and allows SELECT');\n            }\n            return [];\n        }\n        console.log(\"✅ RAW QUERY SUCCESS: Found \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses (count: \").concat(count, \")\"));\n        if (data && data.length > 0) {\n            console.log(\"\\uD83D\\uDCCB Sample raw course data:\", JSON.stringify(data[0], null, 2));\n            console.log(\"\\uD83D\\uDCCB All column names:\", Object.keys(data[0]));\n            console.log(\"\\uD83D\\uDCCB Sample tag value:\", data[0].tag);\n            console.log(\"\\uD83D\\uDCCB Sample priority value:\", data[0].priority);\n        } else {\n            console.warn(\"⚠️ No courses found in database\");\n            console.warn(\"This could mean:\");\n            console.warn(\"1. No courses exist in THIS Supabase project\");\n            console.warn(\"2. RLS policies are blocking the query (but no error shown)\");\n            console.warn(\"3. Wrong Supabase project/credentials\");\n            console.warn(\"\");\n            console.warn(\"\\uD83D\\uDD0D VERIFICATION STEPS:\");\n            console.warn(\"1. Go to Supabase Dashboard → Table Editor → courses\");\n            console.warn(\"2. Check if courses exist there\");\n            console.warn(\"3. Verify the Supabase URL matches:\", supabaseUrl.substring(0, 30) + \"...\");\n            console.warn(\"4. Check RLS policies: Dashboard → Authentication → Policies\");\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"❌ RAW QUERY EXCEPTION:\", error);\n        console.error(\"Exception message:\", error === null || error === void 0 ? void 0 : error.message);\n        console.error(\"Exception stack:\", error === null || error === void 0 ? void 0 : error.stack);\n        return [];\n    }\n}\n/**\n * Test Supabase connection with raw query\n */ async function testSupabaseConnection() {\n    console.log(\"\\uD83E\\uDDEA === TESTING SUPABASE CONNECTION ===\");\n    console.log(\"Supabase URL:\",  true ? \"✅ Set\" : 0);\n    console.log(\"Supabase Key:\",  true ? \"✅ Set\" : 0);\n    const courses = await rawQueryAllCourses();\n    console.log(\"\\uD83D\\uDCCA Connection test result: \".concat(courses.length, \" courses found\"));\n    if (courses.length > 0) {\n        const sample = courses[0];\n        console.log(\"\\uD83D\\uDCCB Sample course columns:\", Object.keys(sample));\n        console.log(\"\\uD83D\\uDCCB Sample course tag value:\", sample.tag);\n        console.log(\"\\uD83D\\uDCCB Sample course type column:\", sample.type || sample.course_type || \"NOT FOUND\");\n    }\n}\n/**\n * Fetches ALL courses - simplest possible query\n */ async function getAllCourses() {\n    try {\n        console.log(\"\\uD83D\\uDCE6 getAllCourses: Starting...\");\n        const rawCourses = await rawQueryAllCourses();\n        if (rawCourses.length === 0) {\n            console.warn(\"⚠️ getAllCourses: No courses found in database\");\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCE6 getAllCourses: Transforming \".concat(rawCourses.length, \" courses...\"));\n        const transformed = rawCourses.map(transformCourse);\n        if (transformed.length > 0) {\n            console.log(\"✅ getAllCourses: Sample transformed course:\", {\n                id: transformed[0].id,\n                title: transformed[0].title,\n                tag: transformed[0].tags,\n                priority: transformed[0].priority\n            });\n        }\n        return transformed;\n    } catch (error) {\n        console.error(\"❌ getAllCourses ERROR:\", error);\n        return [];\n    }\n}\n/**\n * Helper function to get the relevancy column name for a given tag\n */ function getRelevancyColumn(tag) {\n    return tag === \"Business\" ? \"business_relevancy\" : tag === \"Restaurant\" ? \"restaurant_relevancy\" : \"fleet_relevancy\";\n}\n/**\n * Base internal function - fetches courses with flexible options\n * This is the single source of truth for course fetching logic\n * Returns courses with relevancy data preserved (even though Course type doesn't include it)\n */ async function getCoursesByTagInternal(tag) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const { includeHidden = false, limit } = options;\n        const relevancyColumn = getRelevancyColumn(tag);\n        console.log('\\uD83C\\uDFF7️ getCoursesByTagInternal: Fetching courses for tag \"'.concat(tag, '\" (includeHidden: ').concat(includeHidden, \", limit: \").concat(limit || \"none\", \")...\"));\n        console.log('\\uD83C\\uDFF7️ IMPORTANT: NO signup_enabled filter - getting ALL courses for tag \"'.concat(tag, '\"'));\n        console.log(\"\\uD83C\\uDFF7️ Ordering by: \".concat(relevancyColumn, \" (ascending, nullsLast)\"));\n        // Build query step by step - Supabase queries are chainable\n        // CRITICAL: NO FILTERING BY signup_enabled - just get all courses for the tag, sorted by relevancy\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n        // NO .eq('signup_enabled', true) - we want ALL courses regardless of signup_enabled\n        // Order by relevancy column (lower number = higher priority)\n        query = query.order(relevancyColumn || \"priority\", {\n            ascending: true,\n            nullsLast: true\n        });\n        // Apply limit AFTER ordering to ensure we get the top N courses\n        if (limit) {\n            query = query.limit(limit);\n            console.log(\"\\uD83C\\uDFF7️ Limiting to \".concat(limit, \" courses\"));\n        }\n        const { data, error } = await query;\n        // Log the actual results to debug\n        console.log(\"\\uD83C\\uDFF7️ Query executed: returned \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses (limit was \").concat(limit || \"none\", \")\"));\n        if (data && data.length > 0) {\n            console.log(\"\\uD83C\\uDFF7️ Relevancy scores for returned courses:\", data.map((r)=>({\n                    id: r.id,\n                    title: r.title,\n                    [relevancyColumn]: r[relevancyColumn],\n                    signup_enabled: r.signup_enabled\n                })));\n        }\n        if (data && limit && data.length > limit) {\n            console.error(\"❌ ERROR: Query returned \".concat(data.length, \" courses but limit was \").concat(limit, \"! This should not happen.\"));\n        }\n        if (error) {\n            console.error(\"❌ getCoursesByTagInternal DATABASE ERROR:\", error);\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            // Fallback: try using priority if relevancy column doesn't exist\n            console.warn(\"⚠️ Falling back to priority-based ordering...\");\n            let fallbackQuery = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n            fallbackQuery = fallbackQuery.order(\"priority\", {\n                ascending: true,\n                nullsLast: true\n            });\n            if (limit) {\n                fallbackQuery = fallbackQuery.limit(limit);\n            }\n            const { data: fallbackData, error: fallbackError } = await fallbackQuery;\n            if (fallbackError) {\n                console.error(\"❌ Fallback query also failed:\", fallbackError);\n                return [];\n            }\n            const transformed = (fallbackData || []).map(transformCourse);\n            console.log(\"\\uD83C\\uDFF7️ getCoursesByTagInternal (fallback): Returned \".concat(transformed.length, \" courses\"));\n            return transformed;\n        }\n        if (!data || data.length === 0) {\n            console.warn('⚠️ getCoursesByTagInternal: No courses found for tag \"'.concat(tag, '\"'));\n            return [];\n        }\n        // Transform courses - relevancy data exists in raw rows but Course type doesn't include it\n        // The calling code can access it via type assertion if needed (CourseWithRelevancy)\n        let transformed = data.map(transformCourse);\n        // CRITICAL: Enforce limit in case database returns more than requested\n        // This ensures we NEVER return more courses than the limit\n        if (limit && transformed.length > limit) {\n            console.warn(\"⚠️ WARNING: Database returned \".concat(transformed.length, \" courses but limit is \").concat(limit, \". Truncating to \").concat(limit, \".\"));\n            transformed = transformed.slice(0, limit);\n        }\n        console.log(\"\\uD83C\\uDFF7️ getCoursesByTagInternal: Successfully returned \".concat(transformed.length, ' courses for tag \"').concat(tag, '\" (limit was ').concat(limit || \"none\", \")\"));\n        return transformed;\n    } catch (error) {\n        console.error(\"❌ getCoursesByTagInternal EXCEPTION:\", error);\n        console.error(\"Exception message:\", error === null || error === void 0 ? void 0 : error.message);\n        return [];\n    }\n}\n/**\n * For course pages - returns exactly 10 courses sorted by relevancy (no signup_enabled filter)\n */ async function getCoursesByTag(tag) {\n    return getCoursesByTagInternal(tag, {\n        includeHidden: true,\n        limit: 10\n    });\n}\n/**\n * For admin management - returns courses with relevancy data preserved\n * This ensures the management tool shows exactly what course pages display\n */ async function getCoursesByTagWithRelevancy(tag) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { includeHidden = false, limit = 10 } = options;\n    const relevancyColumn = getRelevancyColumn(tag);\n    try {\n        console.log('\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy: Fetching courses for tag \"'.concat(tag, '\" with relevancy data...'));\n        // Build query - same logic as getCoursesByTagInternal but preserve relevancy data\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n        if (!includeHidden) {\n            query = query.eq(\"signup_enabled\", true);\n        }\n        query = query.order(relevancyColumn || \"priority\", {\n            ascending: true,\n            nullsLast: true\n        });\n        if (limit) {\n            query = query.limit(limit);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error(\"❌ getCoursesByTagWithRelevancy DATABASE ERROR:\", error);\n            // Fallback to priority-based ordering\n            let fallbackQuery = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n            if (!includeHidden) {\n                fallbackQuery = fallbackQuery.eq(\"signup_enabled\", true);\n            }\n            fallbackQuery = fallbackQuery.order(\"priority\", {\n                ascending: true,\n                nullsLast: true\n            });\n            if (limit) {\n                fallbackQuery = fallbackQuery.limit(limit);\n            }\n            const { data: fallbackData, error: fallbackError } = await fallbackQuery;\n            if (fallbackError) {\n                console.error(\"❌ Fallback query also failed:\", fallbackError);\n                return [];\n            }\n            // Transform with relevancy data preserved\n            const coursesWithRelevancy = (fallbackData || []).map((row)=>{\n                var _row_business_relevancy, _row_restaurant_relevancy, _row_fleet_relevancy;\n                return {\n                    ...transformCourse(row),\n                    business_relevancy: (_row_business_relevancy = row.business_relevancy) !== null && _row_business_relevancy !== void 0 ? _row_business_relevancy : null,\n                    restaurant_relevancy: (_row_restaurant_relevancy = row.restaurant_relevancy) !== null && _row_restaurant_relevancy !== void 0 ? _row_restaurant_relevancy : null,\n                    fleet_relevancy: (_row_fleet_relevancy = row.fleet_relevancy) !== null && _row_fleet_relevancy !== void 0 ? _row_fleet_relevancy : null\n                };\n            });\n            // Enforce limit\n            const result = limit && coursesWithRelevancy.length > limit ? coursesWithRelevancy.slice(0, limit) : coursesWithRelevancy;\n            console.log(\"\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy (fallback): Returned \".concat(result.length, \" courses\"));\n            return result;\n        }\n        if (!data || data.length === 0) {\n            console.warn('⚠️ getCoursesByTagWithRelevancy: No courses found for tag \"'.concat(tag, '\"'));\n            return [];\n        }\n        // Transform courses and PRESERVE relevancy data from raw database rows\n        // This maintains the exact order from the database query\n        let coursesWithRelevancy = data.map((row)=>{\n            var _row_business_relevancy, _row_restaurant_relevancy, _row_fleet_relevancy;\n            return {\n                ...transformCourse(row),\n                business_relevancy: (_row_business_relevancy = row.business_relevancy) !== null && _row_business_relevancy !== void 0 ? _row_business_relevancy : null,\n                restaurant_relevancy: (_row_restaurant_relevancy = row.restaurant_relevancy) !== null && _row_restaurant_relevancy !== void 0 ? _row_restaurant_relevancy : null,\n                fleet_relevancy: (_row_fleet_relevancy = row.fleet_relevancy) !== null && _row_fleet_relevancy !== void 0 ? _row_fleet_relevancy : null\n            };\n        });\n        // Enforce limit\n        if (limit && coursesWithRelevancy.length > limit) {\n            console.warn(\"⚠️ WARNING: Database returned \".concat(coursesWithRelevancy.length, \" courses but limit is \").concat(limit, \". Truncating to \").concat(limit, \".\"));\n            coursesWithRelevancy = coursesWithRelevancy.slice(0, limit);\n        }\n        console.log(\"\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy: Successfully returned \".concat(coursesWithRelevancy.length, ' courses for tag \"').concat(tag, '\"'));\n        return coursesWithRelevancy;\n    } catch (error) {\n        console.error(\"❌ getCoursesByTagWithRelevancy EXCEPTION:\", error);\n        return [];\n    }\n}\n/**\n * For admin management - returns all courses (visible + hidden) for management\n */ async function getCoursesByTagForManagement(tag) {\n    return getCoursesByTagInternal(tag, {\n        includeHidden: true,\n        limit: 100\n    });\n}\n/**\n * Fetches a single course by ID\n */ async function getCourseById(id) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCourseById: Fetching course \".concat(id, \"...\"));\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"id\", id).maybeSingle();\n        if (error) {\n            console.error(\"❌ getCourseById ERROR:\", error);\n            return null;\n        }\n        if (!data) {\n            console.warn(\"⚠️ getCourseById: Course \".concat(id, \" not found\"));\n            return null;\n        }\n        console.log(\"✅ getCourseById: Found course \".concat(id));\n        return transformCourse(data);\n    } catch (error) {\n        console.error(\"❌ getCourseById EXCEPTION:\", error);\n        return null;\n    }\n}\n/**\n * Fetches featured courses - directly queries database with is_featured filter\n * This is more efficient than fetching all courses and filtering in memory\n */ async function getFeaturedCourses() {\n    try {\n        console.log(\"⭐ getFeaturedCourses: Fetching featured courses from database...\");\n        // Query database directly for featured courses\n        // Only show courses where signup_enabled is true (visible courses)\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"is_featured\", true).eq(\"signup_enabled\", true).order(\"priority\", {\n            ascending: true,\n            nullsFirst: false\n        });\n        if (error) {\n            console.error(\"❌ getFeaturedCourses DATABASE ERROR:\", error);\n            return [];\n        }\n        if (!data || data.length === 0) {\n            console.log(\"⭐ getFeaturedCourses: No featured courses found\");\n            return [];\n        }\n        console.log(\"⭐ getFeaturedCourses: Database returned \".concat(data.length, \" featured courses\"));\n        // Transform database rows to Course objects\n        const featured = data.map(transformCourse);\n        console.log(\"⭐ getFeaturedCourses: Successfully returned \".concat(featured.length, \" featured courses\"));\n        return featured;\n    } catch (error) {\n        console.error(\"❌ getFeaturedCourses ERROR:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxZQUFZO1lBQUVDLFdBQVc7WUFBTWtCLFlBQVk7UUFBTTtRQUUxRCxJQUFJakQsT0FBTztZQUNUVCxRQUFRUyxLQUFLLENBQUMsd0NBQXdDQTtZQUN0RCxPQUFPLEVBQUU7UUFDWDtRQUVBLElBQUksQ0FBQ0QsUUFBUUEsS0FBS1ksTUFBTSxLQUFLLEdBQUc7WUFDOUJwQixRQUFRQyxHQUFHLENBQUM7WUFDWixPQUFPLEVBQUU7UUFDWDtRQUVBRCxRQUFRQyxHQUFHLENBQUMsMkNBQXVELE9BQVpPLEtBQUtZLE1BQU0sRUFBQztRQUVuRSw0Q0FBNEM7UUFDNUMsTUFBTXVDLFdBQVduRCxLQUFLdUIsR0FBRyxDQUFDdEU7UUFFMUJ1QyxRQUFRQyxHQUFHLENBQUMsK0NBQStELE9BQWhCMEQsU0FBU3ZDLE1BQU0sRUFBQztRQUMzRSxPQUFPdUM7SUFDVCxFQUFFLE9BQU9sRCxPQUFPO1FBQ2RULFFBQVFTLEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE9BQU8sRUFBRTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RhdGEvY291cnNlcy50cz83Y2IzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnXG5pbXBvcnQgeyBDb3Vyc2UsIENvdXJzZVRhZywgRGF0YWJhc2VDb3Vyc2UgfSBmcm9tICdAL3R5cGVzL2NvdXJzZSdcblxuLyoqXG4gKiBSYXcgZGF0YWJhc2Ugcm93IHR5cGUgLSBhY2NlcHRzIGFueSBjb2x1bW4gbmFtZSB2YXJpYXRpb25zXG4gKi9cbnR5cGUgUmF3Q291cnNlUm93ID0gUmVjb3JkPHN0cmluZywgYW55PlxuXG4vKipcbiAqIFRyYW5zZm9ybSBmdW5jdGlvbiAtIGhhbmRsZXMgYm90aCAnY291cnNlX3R5cGUnIGFuZCAndHlwZScgY29sdW1uIG5hbWVzXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUNvdXJzZShyb3c6IFJhd0NvdXJzZVJvdyk6IENvdXJzZSB7XG4gIC8vIEhhbmRsZSBib3RoICdjb3Vyc2VfdHlwZScgYW5kICd0eXBlJyBjb2x1bW4gbmFtZXNcbiAgY29uc3QgY291cnNlVHlwZSA9IHJvdy50eXBlIHx8IHJvdy5jb3Vyc2VfdHlwZSB8fCBudWxsXG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBTdHJpbmcocm93LmlkIHx8ICcnKSxcbiAgICB0aXRsZTogU3RyaW5nKHJvdy50aXRsZSB8fCAnJyksXG4gICAgZGVzY3JpcHRpb246IFN0cmluZyhyb3cuZGVzY3JpcHRpb24gfHwgJycpLFxuICAgIGhlYWRsaW5lOiByb3cuaGVhZGxpbmUgfHwgbnVsbCxcbiAgICBidWxsZXRfcG9pbnRzOiBBcnJheS5pc0FycmF5KHJvdy5idWxsZXRfcG9pbnRzKSA/IHJvdy5idWxsZXRfcG9pbnRzIDogbnVsbCxcbiAgICBwcm92aWRlcjogcm93LnByb3ZpZGVyIHx8IG51bGwsXG4gICAgbGV2ZWw6IChyb3cubGV2ZWwgYXMgYW55KSB8fCAnQmVnaW5uZXInLFxuICAgIGR1cmF0aW9uOiBTdHJpbmcocm93LmR1cmF0aW9uIHx8ICcnKSxcbiAgICB0YWdzOiByb3cudGFnID8gW3Jvdy50YWddIDogW10sXG4gICAgZXh0ZXJuYWxfdXJsOiByb3cuZXh0ZXJuYWxfdXJsIHx8IG51bGwsXG4gICAgcHJpb3JpdHk6IE51bWJlcihyb3cucHJpb3JpdHkpIHx8IDk5OSxcbiAgICByYXRpbmc6IHJvdy5yYXRpbmcgPyBOdW1iZXIocm93LnJhdGluZykgOiBudWxsLFxuICAgIHJldmlld3M6IHJvdy5yZXZpZXdzID8gTnVtYmVyKHJvdy5yZXZpZXdzKSA6IG51bGwsXG4gICAgY291cnNlX3R5cGU6IGNvdXJzZVR5cGUsXG4gICAga2V5X3NraWxsczogcm93LmtleV9za2lsbHMgfHwgbnVsbCxcbiAgICBtb2R1bGVzOiByb3cubW9kdWxlcyB8fCBudWxsLFxuICAgIGluc3RydWN0b3JzOiByb3cuaW5zdHJ1Y3RvcnMgfHwgbnVsbCxcbiAgICBlZmZvcnQ6IHJvdy5lZmZvcnQgfHwgbnVsbCxcbiAgICBsYW5ndWFnZXM6IHJvdy5sYW5ndWFnZXMgfHwgbnVsbCxcbiAgICBwcmljZTogcm93LmZyZWVfdHJpYWwgfHwgdW5kZWZpbmVkLFxuICAgIHNvdXJjZTogU3RyaW5nKHJvdy5zb3VyY2UgfHwgJycpLFxuICAgIHNpZ251cF9lbmFibGVkOiBCb29sZWFuKHJvdy5zaWdudXBfZW5hYmxlZCA/PyB0cnVlKSxcbiAgICBpc19mZWF0dXJlZDogQm9vbGVhbihyb3cuaXNfZmVhdHVyZWQgPz8gZmFsc2UpLFxuICAgIHByaWNlX2xhYmVsOiByb3cucHJpY2VfbGFiZWwgfHwgbnVsbCxcbiAgICBmcmVlX3RyaWFsOiByb3cuZnJlZV90cmlhbCB8fCBudWxsLFxuICAgIGNyZWF0ZWRfYXQ6IHJvdy5jcmVhdGVkX2F0IHx8IG51bGwsXG4gICAgdXBkYXRlZF9hdDogcm93LnVwZGF0ZWRfYXQgfHwgbnVsbCxcbiAgfVxufVxuXG4vKipcbiAqIFJhdyBxdWVyeSAtIGp1c3QgZ2V0IGV2ZXJ5dGhpbmcsIG5vIGZpbHRlcnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmF3UXVlcnlBbGxDb3Vyc2VzKCk6IFByb21pc2U8UmF3Q291cnNlUm93W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBSQVcgUVVFUlk6IEZldGNoaW5nIEFMTCBjb3Vyc2VzIHdpdGggbm8gZmlsdGVycy4uLicpXG4gICAgXG4gICAgLy8gTG9nIHRoZSBTdXBhYmFzZSBVUkwgYmVpbmcgdXNlZCAoZmlyc3QgMzAgY2hhcnMgZm9yIHNlY3VyaXR5KVxuICAgIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIHx8ICcnXG4gICAgY29uc29sZS5sb2coJ/CflJcgU3VwYWJhc2UgVVJMOicsIHN1cGFiYXNlVXJsID8gc3VwYWJhc2VVcmwuc3Vic3RyaW5nKDAsIDMwKSArICcuLi4nIDogJ+KdjCBNSVNTSU5HJylcbiAgICBjb25zb2xlLmxvZygn8J+UkSBBbm9uIEtleTonLCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSA/ICfinIUgU2V0JyA6ICfinYwgTUlTU0lORycpXG4gICAgXG4gICAgLy8gVHJ5IHRoZSBzaW1wbGVzdCBwb3NzaWJsZSBxdWVyeSBmaXJzdFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2NvdXJzZXMnKVxuICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcgfSlcbiAgICAgIC5saW1pdCgxMDApIC8vIEFkZCBleHBsaWNpdCBsaW1pdFxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUkFXIFFVRVJZIEVSUk9SOicsIGVycm9yKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29kZTonLCBlcnJvci5jb2RlKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGludDonLCBlcnJvci5oaW50KVxuICAgICAgY29uc29sZS5lcnJvcignRnVsbCBlcnJvcjonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICBcbiAgICAgIC8vIElmIGl0J3MgYW4gUkxTIGVycm9yLCBwcm92aWRlIGhlbHBmdWwgbWVzc2FnZVxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDMwMScgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncG9saWN5JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign8J+UkiBSTFMgRVJST1I6IFJvdyBMZXZlbCBTZWN1cml0eSBpcyBibG9ja2luZyB0aGUgcXVlcnkhJylcbiAgICAgICAgY29uc29sZS5lcnJvcignQ2hlY2sgeW91ciBTdXBhYmFzZSBSTFMgcG9saWNpZXMgZm9yIHRoZSBjb3Vyc2VzIHRhYmxlLicpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dvIHRvIFN1cGFiYXNlIERhc2hib2FyZCDihpIgQXV0aGVudGljYXRpb24g4oaSIFBvbGljaWVzIOKGkiBjb3Vyc2VzIHRhYmxlJylcbiAgICAgICAgY29uc29sZS5lcnJvcignTWFrZSBzdXJlIFwiY291cnNlc19zZWxlY3RfcHVibGljXCIgcG9saWN5IGV4aXN0cyBhbmQgYWxsb3dzIFNFTEVDVCcpXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDinIUgUkFXIFFVRVJZIFNVQ0NFU1M6IEZvdW5kICR7ZGF0YT8ubGVuZ3RoIHx8IDB9IGNvdXJzZXMgKGNvdW50OiAke2NvdW50fSlgKVxuICAgIFxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk4sgU2FtcGxlIHJhdyBjb3Vyc2UgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhWzBdLCBudWxsLCAyKSlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEFsbCBjb2x1bW4gbmFtZXM6JywgT2JqZWN0LmtleXMoZGF0YVswXSkpXG4gICAgICBjb25zb2xlLmxvZygn8J+TiyBTYW1wbGUgdGFnIHZhbHVlOicsIGRhdGFbMF0udGFnKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4sgU2FtcGxlIHByaW9yaXR5IHZhbHVlOicsIGRhdGFbMF0ucHJpb3JpdHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGNvdXJzZXMgZm91bmQgaW4gZGF0YWJhc2UnKVxuICAgICAgY29uc29sZS53YXJuKCdUaGlzIGNvdWxkIG1lYW46JylcbiAgICAgIGNvbnNvbGUud2FybignMS4gTm8gY291cnNlcyBleGlzdCBpbiBUSElTIFN1cGFiYXNlIHByb2plY3QnKVxuICAgICAgY29uc29sZS53YXJuKCcyLiBSTFMgcG9saWNpZXMgYXJlIGJsb2NraW5nIHRoZSBxdWVyeSAoYnV0IG5vIGVycm9yIHNob3duKScpXG4gICAgICBjb25zb2xlLndhcm4oJzMuIFdyb25nIFN1cGFiYXNlIHByb2plY3QvY3JlZGVudGlhbHMnKVxuICAgICAgY29uc29sZS53YXJuKCcnKVxuICAgICAgY29uc29sZS53YXJuKCfwn5SNIFZFUklGSUNBVElPTiBTVEVQUzonKVxuICAgICAgY29uc29sZS53YXJuKCcxLiBHbyB0byBTdXBhYmFzZSBEYXNoYm9hcmQg4oaSIFRhYmxlIEVkaXRvciDihpIgY291cnNlcycpXG4gICAgICBjb25zb2xlLndhcm4oJzIuIENoZWNrIGlmIGNvdXJzZXMgZXhpc3QgdGhlcmUnKVxuICAgICAgY29uc29sZS53YXJuKCczLiBWZXJpZnkgdGhlIFN1cGFiYXNlIFVSTCBtYXRjaGVzOicsIHN1cGFiYXNlVXJsLnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJylcbiAgICAgIGNvbnNvbGUud2FybignNC4gQ2hlY2sgUkxTIHBvbGljaWVzOiBEYXNoYm9hcmQg4oaSIEF1dGhlbnRpY2F0aW9uIOKGkiBQb2xpY2llcycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBSQVcgUVVFUlkgRVhDRVBUSU9OOicsIGVycm9yKVxuICAgIGNvbnNvbGUuZXJyb3IoJ0V4Y2VwdGlvbiBtZXNzYWdlOicsIGVycm9yPy5tZXNzYWdlKVxuICAgIGNvbnNvbGUuZXJyb3IoJ0V4Y2VwdGlvbiBzdGFjazonLCBlcnJvcj8uc3RhY2spXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0IFN1cGFiYXNlIGNvbm5lY3Rpb24gd2l0aCByYXcgcXVlcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RTdXBhYmFzZUNvbm5lY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnNvbGUubG9nKCfwn6eqID09PSBURVNUSU5HIFNVUEFCQVNFIENPTk5FQ1RJT04gPT09JylcbiAgY29uc29sZS5sb2coJ1N1cGFiYXNlIFVSTDonLCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPyAn4pyFIFNldCcgOiAn4p2MIE1pc3NpbmcnKVxuICBjb25zb2xlLmxvZygnU3VwYWJhc2UgS2V5OicsIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZID8gJ+KchSBTZXQnIDogJ+KdjCBNaXNzaW5nJylcbiAgXG4gIGNvbnN0IGNvdXJzZXMgPSBhd2FpdCByYXdRdWVyeUFsbENvdXJzZXMoKVxuICBjb25zb2xlLmxvZyhg8J+TiiBDb25uZWN0aW9uIHRlc3QgcmVzdWx0OiAke2NvdXJzZXMubGVuZ3RofSBjb3Vyc2VzIGZvdW5kYClcbiAgXG4gIGlmIChjb3Vyc2VzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzYW1wbGUgPSBjb3Vyc2VzWzBdXG4gICAgY29uc29sZS5sb2coJ/Cfk4sgU2FtcGxlIGNvdXJzZSBjb2x1bW5zOicsIE9iamVjdC5rZXlzKHNhbXBsZSkpXG4gICAgY29uc29sZS5sb2coJ/Cfk4sgU2FtcGxlIGNvdXJzZSB0YWcgdmFsdWU6Jywgc2FtcGxlLnRhZylcbiAgICBjb25zb2xlLmxvZygn8J+TiyBTYW1wbGUgY291cnNlIHR5cGUgY29sdW1uOicsIHNhbXBsZS50eXBlIHx8IHNhbXBsZS5jb3Vyc2VfdHlwZSB8fCAnTk9UIEZPVU5EJylcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoZXMgQUxMIGNvdXJzZXMgLSBzaW1wbGVzdCBwb3NzaWJsZSBxdWVyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQ291cnNlcygpOiBQcm9taXNlPENvdXJzZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/Cfk6YgZ2V0QWxsQ291cnNlczogU3RhcnRpbmcuLi4nKVxuICAgIFxuICAgIGNvbnN0IHJhd0NvdXJzZXMgPSBhd2FpdCByYXdRdWVyeUFsbENvdXJzZXMoKVxuICAgIFxuICAgIGlmIChyYXdDb3Vyc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gZ2V0QWxsQ291cnNlczogTm8gY291cnNlcyBmb3VuZCBpbiBkYXRhYmFzZScpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg8J+TpiBnZXRBbGxDb3Vyc2VzOiBUcmFuc2Zvcm1pbmcgJHtyYXdDb3Vyc2VzLmxlbmd0aH0gY291cnNlcy4uLmApXG4gICAgY29uc3QgdHJhbnNmb3JtZWQgPSByYXdDb3Vyc2VzLm1hcCh0cmFuc2Zvcm1Db3Vyc2UpXG4gICAgXG4gICAgaWYgKHRyYW5zZm9ybWVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgZ2V0QWxsQ291cnNlczogU2FtcGxlIHRyYW5zZm9ybWVkIGNvdXJzZTonLCB7XG4gICAgICAgIGlkOiB0cmFuc2Zvcm1lZFswXS5pZCxcbiAgICAgICAgdGl0bGU6IHRyYW5zZm9ybWVkWzBdLnRpdGxlLFxuICAgICAgICB0YWc6IHRyYW5zZm9ybWVkWzBdLnRhZ3MsXG4gICAgICAgIHByaW9yaXR5OiB0cmFuc2Zvcm1lZFswXS5wcmlvcml0eSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldEFsbENvdXJzZXMgRVJST1I6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSByZWxldmFuY3kgY29sdW1uIG5hbWUgZm9yIGEgZ2l2ZW4gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxldmFuY3lDb2x1bW4odGFnOiBDb3Vyc2VUYWcpOiBzdHJpbmcge1xuICByZXR1cm4gdGFnID09PSAnQnVzaW5lc3MnIFxuICAgID8gJ2J1c2luZXNzX3JlbGV2YW5jeScgXG4gICAgOiB0YWcgPT09ICdSZXN0YXVyYW50JyBcbiAgICA/ICdyZXN0YXVyYW50X3JlbGV2YW5jeScgXG4gICAgOiAnZmxlZXRfcmVsZXZhbmN5J1xufVxuXG4vKipcbiAqIEJhc2UgaW50ZXJuYWwgZnVuY3Rpb24gLSBmZXRjaGVzIGNvdXJzZXMgd2l0aCBmbGV4aWJsZSBvcHRpb25zXG4gKiBUaGlzIGlzIHRoZSBzaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciBjb3Vyc2UgZmV0Y2hpbmcgbG9naWNcbiAqIFJldHVybnMgY291cnNlcyB3aXRoIHJlbGV2YW5jeSBkYXRhIHByZXNlcnZlZCAoZXZlbiB0aG91Z2ggQ291cnNlIHR5cGUgZG9lc24ndCBpbmNsdWRlIGl0KVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbChcbiAgdGFnOiBDb3Vyc2VUYWcsIFxuICBvcHRpb25zOiB7XG4gICAgaW5jbHVkZUhpZGRlbj86IGJvb2xlYW5cbiAgICBsaW1pdD86IG51bWJlclxuICB9ID0ge31cbik6IFByb21pc2U8Q291cnNlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGluY2x1ZGVIaWRkZW4gPSBmYWxzZSwgbGltaXQgfSA9IG9wdGlvbnNcbiAgICBjb25zdCByZWxldmFuY3lDb2x1bW4gPSBnZXRSZWxldmFuY3lDb2x1bW4odGFnKVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIGdldENvdXJzZXNCeVRhZ0ludGVybmFsOiBGZXRjaGluZyBjb3Vyc2VzIGZvciB0YWcgXCIke3RhZ31cIiAoaW5jbHVkZUhpZGRlbjogJHtpbmNsdWRlSGlkZGVufSwgbGltaXQ6ICR7bGltaXQgfHwgJ25vbmUnfSkuLi5gKVxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIElNUE9SVEFOVDogTk8gc2lnbnVwX2VuYWJsZWQgZmlsdGVyIC0gZ2V0dGluZyBBTEwgY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCJgKVxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIE9yZGVyaW5nIGJ5OiAke3JlbGV2YW5jeUNvbHVtbn0gKGFzY2VuZGluZywgbnVsbHNMYXN0KWApXG4gICAgXG4gICAgLy8gQnVpbGQgcXVlcnkgc3RlcCBieSBzdGVwIC0gU3VwYWJhc2UgcXVlcmllcyBhcmUgY2hhaW5hYmxlXG4gICAgLy8gQ1JJVElDQUw6IE5PIEZJTFRFUklORyBCWSBzaWdudXBfZW5hYmxlZCAtIGp1c3QgZ2V0IGFsbCBjb3Vyc2VzIGZvciB0aGUgdGFnLCBzb3J0ZWQgYnkgcmVsZXZhbmN5XG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0YWcnLCB0YWcpXG4gICAgICAvLyBOTyAuZXEoJ3NpZ251cF9lbmFibGVkJywgdHJ1ZSkgLSB3ZSB3YW50IEFMTCBjb3Vyc2VzIHJlZ2FyZGxlc3Mgb2Ygc2lnbnVwX2VuYWJsZWRcbiAgICBcbiAgICAvLyBPcmRlciBieSByZWxldmFuY3kgY29sdW1uIChsb3dlciBudW1iZXIgPSBoaWdoZXIgcHJpb3JpdHkpXG4gICAgcXVlcnkgPSBxdWVyeS5vcmRlcihyZWxldmFuY3lDb2x1bW4gfHwgJ3ByaW9yaXR5JywgeyBhc2NlbmRpbmc6IHRydWUsIG51bGxzTGFzdDogdHJ1ZSB9KVxuICAgIFxuICAgIC8vIEFwcGx5IGxpbWl0IEFGVEVSIG9yZGVyaW5nIHRvIGVuc3VyZSB3ZSBnZXQgdGhlIHRvcCBOIGNvdXJzZXNcbiAgICBpZiAobGltaXQpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkubGltaXQobGltaXQpXG4gICAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBMaW1pdGluZyB0byAke2xpbWl0fSBjb3Vyc2VzYClcbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcbiAgICBcbiAgICAvLyBMb2cgdGhlIGFjdHVhbCByZXN1bHRzIHRvIGRlYnVnXG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gUXVlcnkgZXhlY3V0ZWQ6IHJldHVybmVkICR7ZGF0YT8ubGVuZ3RoIHx8IDB9IGNvdXJzZXMgKGxpbWl0IHdhcyAke2xpbWl0IHx8ICdub25lJ30pYClcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+377iPIFJlbGV2YW5jeSBzY29yZXMgZm9yIHJldHVybmVkIGNvdXJzZXM6YCwgZGF0YS5tYXAoKHI6IGFueSkgPT4gKHtcbiAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgIHRpdGxlOiByLnRpdGxlLFxuICAgICAgICBbcmVsZXZhbmN5Q29sdW1uXTogcltyZWxldmFuY3lDb2x1bW5dLFxuICAgICAgICBzaWdudXBfZW5hYmxlZDogci5zaWdudXBfZW5hYmxlZFxuICAgICAgfSkpKVxuICAgIH1cbiAgICBpZiAoZGF0YSAmJiBsaW1pdCAmJiBkYXRhLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRVJST1I6IFF1ZXJ5IHJldHVybmVkICR7ZGF0YS5sZW5ndGh9IGNvdXJzZXMgYnV0IGxpbWl0IHdhcyAke2xpbWl0fSEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi5gKVxuICAgIH1cbiAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCBEQVRBQkFTRSBFUlJPUjonLCBlcnJvcilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2s6IHRyeSB1c2luZyBwcmlvcml0eSBpZiByZWxldmFuY3kgY29sdW1uIGRvZXNuJ3QgZXhpc3RcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEZhbGxpbmcgYmFjayB0byBwcmlvcml0eS1iYXNlZCBvcmRlcmluZy4uLicpXG4gICAgICBsZXQgZmFsbGJhY2tRdWVyeSA9IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgICAgXG4gICAgICBmYWxsYmFja1F1ZXJ5ID0gZmFsbGJhY2tRdWVyeS5vcmRlcigncHJpb3JpdHknLCB7IGFzY2VuZGluZzogdHJ1ZSwgbnVsbHNMYXN0OiB0cnVlIH0pXG4gICAgICBcbiAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICBmYWxsYmFja1F1ZXJ5ID0gZmFsbGJhY2tRdWVyeS5saW1pdChsaW1pdClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhOiBmYWxsYmFja0RhdGEsIGVycm9yOiBmYWxsYmFja0Vycm9yIH0gPSBhd2FpdCBmYWxsYmFja1F1ZXJ5XG4gICAgICBcbiAgICAgIGlmIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWxsYmFjayBxdWVyeSBhbHNvIGZhaWxlZDonLCBmYWxsYmFja0Vycm9yKVxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSAoZmFsbGJhY2tEYXRhIHx8IFtdKS5tYXAodHJhbnNmb3JtQ291cnNlKVxuICAgICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwgKGZhbGxiYWNrKTogUmV0dXJuZWQgJHt0cmFuc2Zvcm1lZC5sZW5ndGh9IGNvdXJzZXNgKVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkXG4gICAgfVxuICAgIFxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWw6IE5vIGNvdXJzZXMgZm91bmQgZm9yIHRhZyBcIiR7dGFnfVwiYClcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gY291cnNlcyAtIHJlbGV2YW5jeSBkYXRhIGV4aXN0cyBpbiByYXcgcm93cyBidXQgQ291cnNlIHR5cGUgZG9lc24ndCBpbmNsdWRlIGl0XG4gICAgLy8gVGhlIGNhbGxpbmcgY29kZSBjYW4gYWNjZXNzIGl0IHZpYSB0eXBlIGFzc2VydGlvbiBpZiBuZWVkZWQgKENvdXJzZVdpdGhSZWxldmFuY3kpXG4gICAgbGV0IHRyYW5zZm9ybWVkID0gZGF0YS5tYXAodHJhbnNmb3JtQ291cnNlKVxuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBFbmZvcmNlIGxpbWl0IGluIGNhc2UgZGF0YWJhc2UgcmV0dXJucyBtb3JlIHRoYW4gcmVxdWVzdGVkXG4gICAgLy8gVGhpcyBlbnN1cmVzIHdlIE5FVkVSIHJldHVybiBtb3JlIGNvdXJzZXMgdGhhbiB0aGUgbGltaXRcbiAgICBpZiAobGltaXQgJiYgdHJhbnNmb3JtZWQubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFdBUk5JTkc6IERhdGFiYXNlIHJldHVybmVkICR7dHJhbnNmb3JtZWQubGVuZ3RofSBjb3Vyc2VzIGJ1dCBsaW1pdCBpcyAke2xpbWl0fS4gVHJ1bmNhdGluZyB0byAke2xpbWl0fS5gKVxuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1lZC5zbGljZSgwLCBsaW1pdClcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWw6IFN1Y2Nlc3NmdWxseSByZXR1cm5lZCAke3RyYW5zZm9ybWVkLmxlbmd0aH0gY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCIgKGxpbWl0IHdhcyAke2xpbWl0IHx8ICdub25lJ30pYClcbiAgICBcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCBFWENFUFRJT046JywgZXJyb3IpXG4gICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIG1lc3NhZ2U6JywgZXJyb3I/Lm1lc3NhZ2UpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGNvdXJzZXMgd2l0aCByZWxldmFuY3kgZGF0YSAodXNlZCBieSBhZG1pbiBtYW5hZ2VtZW50KVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvdXJzZVdpdGhSZWxldmFuY3kgZXh0ZW5kcyBDb3Vyc2Uge1xuICBidXNpbmVzc19yZWxldmFuY3k/OiBudW1iZXIgfCBudWxsXG4gIHJlc3RhdXJhbnRfcmVsZXZhbmN5PzogbnVtYmVyIHwgbnVsbFxuICBmbGVldF9yZWxldmFuY3k/OiBudW1iZXIgfCBudWxsXG59XG5cbi8qKlxuICogRm9yIGNvdXJzZSBwYWdlcyAtIHJldHVybnMgZXhhY3RseSAxMCBjb3Vyc2VzIHNvcnRlZCBieSByZWxldmFuY3kgKG5vIHNpZ251cF9lbmFibGVkIGZpbHRlcilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZXNCeVRhZyh0YWc6IENvdXJzZVRhZyk6IFByb21pc2U8Q291cnNlW10+IHtcbiAgcmV0dXJuIGdldENvdXJzZXNCeVRhZ0ludGVybmFsKHRhZywgeyBpbmNsdWRlSGlkZGVuOiB0cnVlLCBsaW1pdDogMTAgfSlcbn1cblxuLyoqXG4gKiBGb3IgYWRtaW4gbWFuYWdlbWVudCAtIHJldHVybnMgY291cnNlcyB3aXRoIHJlbGV2YW5jeSBkYXRhIHByZXNlcnZlZFxuICogVGhpcyBlbnN1cmVzIHRoZSBtYW5hZ2VtZW50IHRvb2wgc2hvd3MgZXhhY3RseSB3aGF0IGNvdXJzZSBwYWdlcyBkaXNwbGF5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5KFxuICB0YWc6IENvdXJzZVRhZyxcbiAgb3B0aW9uczogeyBpbmNsdWRlSGlkZGVuPzogYm9vbGVhbjsgbGltaXQ/OiBudW1iZXIgfSA9IHt9XG4pOiBQcm9taXNlPENvdXJzZVdpdGhSZWxldmFuY3lbXT4ge1xuICBjb25zdCB7IGluY2x1ZGVIaWRkZW4gPSBmYWxzZSwgbGltaXQgPSAxMCB9ID0gb3B0aW9uc1xuICBjb25zdCByZWxldmFuY3lDb2x1bW4gPSBnZXRSZWxldmFuY3lDb2x1bW4odGFnKVxuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5OiBGZXRjaGluZyBjb3Vyc2VzIGZvciB0YWcgXCIke3RhZ31cIiB3aXRoIHJlbGV2YW5jeSBkYXRhLi4uYClcbiAgICBcbiAgICAvLyBCdWlsZCBxdWVyeSAtIHNhbWUgbG9naWMgYXMgZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwgYnV0IHByZXNlcnZlIHJlbGV2YW5jeSBkYXRhXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0YWcnLCB0YWcpXG4gICAgXG4gICAgaWYgKCFpbmNsdWRlSGlkZGVuKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdzaWdudXBfZW5hYmxlZCcsIHRydWUpXG4gICAgfVxuICAgIFxuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIocmVsZXZhbmN5Q29sdW1uIHx8ICdwcmlvcml0eScsIHsgYXNjZW5kaW5nOiB0cnVlLCBudWxsc0xhc3Q6IHRydWUgfSlcbiAgICBcbiAgICBpZiAobGltaXQpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkubGltaXQobGltaXQpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q291cnNlc0J5VGFnV2l0aFJlbGV2YW5jeSBEQVRBQkFTRSBFUlJPUjonLCBlcnJvcilcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHByaW9yaXR5LWJhc2VkIG9yZGVyaW5nXG4gICAgICBsZXQgZmFsbGJhY2tRdWVyeSA9IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgICAgXG4gICAgICBpZiAoIWluY2x1ZGVIaWRkZW4pIHtcbiAgICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkuZXEoJ3NpZ251cF9lbmFibGVkJywgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkub3JkZXIoJ3ByaW9yaXR5JywgeyBhc2NlbmRpbmc6IHRydWUsIG51bGxzTGFzdDogdHJ1ZSB9KVxuICAgICAgXG4gICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkubGltaXQobGltaXQpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogZmFsbGJhY2tEYXRhLCBlcnJvcjogZmFsbGJhY2tFcnJvciB9ID0gYXdhaXQgZmFsbGJhY2tRdWVyeVxuICAgICAgXG4gICAgICBpZiAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFsbGJhY2sgcXVlcnkgYWxzbyBmYWlsZWQ6JywgZmFsbGJhY2tFcnJvcilcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRyYW5zZm9ybSB3aXRoIHJlbGV2YW5jeSBkYXRhIHByZXNlcnZlZFxuICAgICAgY29uc3QgY291cnNlc1dpdGhSZWxldmFuY3kgPSAoZmFsbGJhY2tEYXRhIHx8IFtdKS5tYXAocm93ID0+ICh7XG4gICAgICAgIC4uLnRyYW5zZm9ybUNvdXJzZShyb3cpLFxuICAgICAgICBidXNpbmVzc19yZWxldmFuY3k6IHJvdy5idXNpbmVzc19yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgICAgcmVzdGF1cmFudF9yZWxldmFuY3k6IHJvdy5yZXN0YXVyYW50X3JlbGV2YW5jeSA/PyBudWxsLFxuICAgICAgICBmbGVldF9yZWxldmFuY3k6IHJvdy5mbGVldF9yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgIH0pKSBhcyBDb3Vyc2VXaXRoUmVsZXZhbmN5W11cbiAgICAgIFxuICAgICAgLy8gRW5mb3JjZSBsaW1pdFxuICAgICAgY29uc3QgcmVzdWx0ID0gbGltaXQgJiYgY291cnNlc1dpdGhSZWxldmFuY3kubGVuZ3RoID4gbGltaXQgXG4gICAgICAgID8gY291cnNlc1dpdGhSZWxldmFuY3kuc2xpY2UoMCwgbGltaXQpXG4gICAgICAgIDogY291cnNlc1dpdGhSZWxldmFuY3lcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnV2l0aFJlbGV2YW5jeSAoZmFsbGJhY2spOiBSZXR1cm5lZCAke3Jlc3VsdC5sZW5ndGh9IGNvdXJzZXNgKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3k6IE5vIGNvdXJzZXMgZm91bmQgZm9yIHRhZyBcIiR7dGFnfVwiYClcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gY291cnNlcyBhbmQgUFJFU0VSVkUgcmVsZXZhbmN5IGRhdGEgZnJvbSByYXcgZGF0YWJhc2Ugcm93c1xuICAgIC8vIFRoaXMgbWFpbnRhaW5zIHRoZSBleGFjdCBvcmRlciBmcm9tIHRoZSBkYXRhYmFzZSBxdWVyeVxuICAgIGxldCBjb3Vyc2VzV2l0aFJlbGV2YW5jeSA9IGRhdGEubWFwKHJvdyA9PiAoe1xuICAgICAgLi4udHJhbnNmb3JtQ291cnNlKHJvdyksXG4gICAgICBidXNpbmVzc19yZWxldmFuY3k6IHJvdy5idXNpbmVzc19yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgIHJlc3RhdXJhbnRfcmVsZXZhbmN5OiByb3cucmVzdGF1cmFudF9yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgIGZsZWV0X3JlbGV2YW5jeTogcm93LmZsZWV0X3JlbGV2YW5jeSA/PyBudWxsLFxuICAgIH0pKSBhcyBDb3Vyc2VXaXRoUmVsZXZhbmN5W11cbiAgICBcbiAgICAvLyBFbmZvcmNlIGxpbWl0XG4gICAgaWYgKGxpbWl0ICYmIGNvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXQVJOSU5HOiBEYXRhYmFzZSByZXR1cm5lZCAke2NvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aH0gY291cnNlcyBidXQgbGltaXQgaXMgJHtsaW1pdH0uIFRydW5jYXRpbmcgdG8gJHtsaW1pdH0uYClcbiAgICAgIGNvdXJzZXNXaXRoUmVsZXZhbmN5ID0gY291cnNlc1dpdGhSZWxldmFuY3kuc2xpY2UoMCwgbGltaXQpXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3k6IFN1Y2Nlc3NmdWxseSByZXR1cm5lZCAke2NvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aH0gY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCJgKVxuICAgIHJldHVybiBjb3Vyc2VzV2l0aFJlbGV2YW5jeVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3kgRVhDRVBUSU9OOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8qKlxuICogRm9yIGFkbWluIG1hbmFnZW1lbnQgLSByZXR1cm5zIGFsbCBjb3Vyc2VzICh2aXNpYmxlICsgaGlkZGVuKSBmb3IgbWFuYWdlbWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlc0J5VGFnRm9yTWFuYWdlbWVudCh0YWc6IENvdXJzZVRhZyk6IFByb21pc2U8Q291cnNlW10+IHtcbiAgcmV0dXJuIGdldENvdXJzZXNCeVRhZ0ludGVybmFsKHRhZywgeyBpbmNsdWRlSGlkZGVuOiB0cnVlLCBsaW1pdDogMTAwIH0pXG59XG5cbi8qKlxuICogRmV0Y2hlcyBhIHNpbmdsZSBjb3Vyc2UgYnkgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8Q291cnNlIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGDwn5SNIGdldENvdXJzZUJ5SWQ6IEZldGNoaW5nIGNvdXJzZSAke2lkfS4uLmApXG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLm1heWJlU2luZ2xlKClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZUJ5SWQgRVJST1I6JywgZXJyb3IpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmICghZGF0YSkge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gZ2V0Q291cnNlQnlJZDogQ291cnNlICR7aWR9IG5vdCBmb3VuZGApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDinIUgZ2V0Q291cnNlQnlJZDogRm91bmQgY291cnNlICR7aWR9YClcbiAgICByZXR1cm4gdHJhbnNmb3JtQ291cnNlKGRhdGEpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZUJ5SWQgRVhDRVBUSU9OOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIGZlYXR1cmVkIGNvdXJzZXMgLSBkaXJlY3RseSBxdWVyaWVzIGRhdGFiYXNlIHdpdGggaXNfZmVhdHVyZWQgZmlsdGVyXG4gKiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gZmV0Y2hpbmcgYWxsIGNvdXJzZXMgYW5kIGZpbHRlcmluZyBpbiBtZW1vcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZlYXR1cmVkQ291cnNlcygpOiBQcm9taXNlPENvdXJzZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ+KtkCBnZXRGZWF0dXJlZENvdXJzZXM6IEZldGNoaW5nIGZlYXR1cmVkIGNvdXJzZXMgZnJvbSBkYXRhYmFzZS4uLicpXG4gICAgXG4gICAgLy8gUXVlcnkgZGF0YWJhc2UgZGlyZWN0bHkgZm9yIGZlYXR1cmVkIGNvdXJzZXNcbiAgICAvLyBPbmx5IHNob3cgY291cnNlcyB3aGVyZSBzaWdudXBfZW5hYmxlZCBpcyB0cnVlICh2aXNpYmxlIGNvdXJzZXMpXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpc19mZWF0dXJlZCcsIHRydWUpXG4gICAgICAuZXEoJ3NpZ251cF9lbmFibGVkJywgdHJ1ZSlcbiAgICAgIC5vcmRlcigncHJpb3JpdHknLCB7IGFzY2VuZGluZzogdHJ1ZSwgbnVsbHNGaXJzdDogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldEZlYXR1cmVkQ291cnNlcyBEQVRBQkFTRSBFUlJPUjonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ+KtkCBnZXRGZWF0dXJlZENvdXJzZXM6IE5vIGZlYXR1cmVkIGNvdXJzZXMgZm91bmQnKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYOKtkCBnZXRGZWF0dXJlZENvdXJzZXM6IERhdGFiYXNlIHJldHVybmVkICR7ZGF0YS5sZW5ndGh9IGZlYXR1cmVkIGNvdXJzZXNgKVxuICAgIFxuICAgIC8vIFRyYW5zZm9ybSBkYXRhYmFzZSByb3dzIHRvIENvdXJzZSBvYmplY3RzXG4gICAgY29uc3QgZmVhdHVyZWQgPSBkYXRhLm1hcCh0cmFuc2Zvcm1Db3Vyc2UpXG5cbiAgICBjb25zb2xlLmxvZyhg4q2QIGdldEZlYXR1cmVkQ291cnNlczogU3VjY2Vzc2Z1bGx5IHJldHVybmVkICR7ZmVhdHVyZWQubGVuZ3RofSBmZWF0dXJlZCBjb3Vyc2VzYClcbiAgICByZXR1cm4gZmVhdHVyZWRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0RmVhdHVyZWRDb3Vyc2VzIEVSUk9SOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJ0cmFuc2Zvcm1Db3Vyc2UiLCJyb3ciLCJjb3Vyc2VUeXBlIiwidHlwZSIsImNvdXJzZV90eXBlIiwiaWQiLCJTdHJpbmciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiaGVhZGxpbmUiLCJidWxsZXRfcG9pbnRzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvdmlkZXIiLCJsZXZlbCIsImR1cmF0aW9uIiwidGFncyIsInRhZyIsImV4dGVybmFsX3VybCIsInByaW9yaXR5IiwiTnVtYmVyIiwicmF0aW5nIiwicmV2aWV3cyIsImtleV9za2lsbHMiLCJtb2R1bGVzIiwiaW5zdHJ1Y3RvcnMiLCJlZmZvcnQiLCJsYW5ndWFnZXMiLCJwcmljZSIsImZyZWVfdHJpYWwiLCJ1bmRlZmluZWQiLCJzb3VyY2UiLCJzaWdudXBfZW5hYmxlZCIsIkJvb2xlYW4iLCJpc19mZWF0dXJlZCIsInByaWNlX2xhYmVsIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJyYXdRdWVyeUFsbENvdXJzZXMiLCJjb25zb2xlIiwibG9nIiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3Vic3RyaW5nIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJkYXRhIiwiZXJyb3IiLCJjb3VudCIsImZyb20iLCJzZWxlY3QiLCJsaW1pdCIsImNvZGUiLCJtZXNzYWdlIiwiaGludCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbmNsdWRlcyIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJ3YXJuIiwic3RhY2siLCJ0ZXN0U3VwYWJhc2VDb25uZWN0aW9uIiwiY291cnNlcyIsInNhbXBsZSIsImdldEFsbENvdXJzZXMiLCJyYXdDb3Vyc2VzIiwidHJhbnNmb3JtZWQiLCJtYXAiLCJnZXRSZWxldmFuY3lDb2x1bW4iLCJnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCIsIm9wdGlvbnMiLCJpbmNsdWRlSGlkZGVuIiwicmVsZXZhbmN5Q29sdW1uIiwicXVlcnkiLCJlcSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibnVsbHNMYXN0IiwiciIsImZhbGxiYWNrUXVlcnkiLCJmYWxsYmFja0RhdGEiLCJmYWxsYmFja0Vycm9yIiwic2xpY2UiLCJnZXRDb3Vyc2VzQnlUYWciLCJnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5IiwiY291cnNlc1dpdGhSZWxldmFuY3kiLCJidXNpbmVzc19yZWxldmFuY3kiLCJyZXN0YXVyYW50X3JlbGV2YW5jeSIsImZsZWV0X3JlbGV2YW5jeSIsInJlc3VsdCIsImdldENvdXJzZXNCeVRhZ0Zvck1hbmFnZW1lbnQiLCJnZXRDb3Vyc2VCeUlkIiwibWF5YmVTaW5nbGUiLCJnZXRGZWF0dXJlZENvdXJzZXMiLCJudWxsc0ZpcnN0IiwiZmVhdHVyZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/courses.ts\n"));

/***/ })

});