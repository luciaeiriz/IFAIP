"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/courses/business/page",{

/***/ "(app-pages-browser)/./src/data/courses.ts":
/*!*****************************!*\
  !*** ./src/data/courses.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getCourseById: function() { return /* binding */ getCourseById; },\n/* harmony export */   getCoursesByTag: function() { return /* binding */ getCoursesByTag; },\n/* harmony export */   getCoursesByTagForManagement: function() { return /* binding */ getCoursesByTagForManagement; },\n/* harmony export */   getCoursesByTagWithRelevancy: function() { return /* binding */ getCoursesByTagWithRelevancy; },\n/* harmony export */   getFeaturedCourses: function() { return /* binding */ getFeaturedCourses; },\n/* harmony export */   getRelevancyColumn: function() { return /* binding */ getRelevancyColumn; },\n/* harmony export */   testSupabaseConnection: function() { return /* binding */ testSupabaseConnection; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n/**\n * Transform function - handles both 'course_type' and 'type' column names\n */ function transformCourse(row) {\n    // Handle both 'course_type' and 'type' column names\n    const courseType = row.type || row.course_type || null;\n    var _row_signup_enabled, _row_is_featured;\n    return {\n        id: String(row.id || \"\"),\n        title: String(row.title || \"\"),\n        description: String(row.description || \"\"),\n        headline: row.headline || null,\n        bullet_points: Array.isArray(row.bullet_points) ? row.bullet_points : null,\n        provider: row.provider || null,\n        level: row.level || \"Beginner\",\n        duration: String(row.duration || \"\"),\n        tags: row.tag ? [\n            row.tag\n        ] : [],\n        external_url: row.external_url || null,\n        priority: Number(row.priority) || 999,\n        rating: row.rating ? Number(row.rating) : null,\n        reviews: row.reviews ? Number(row.reviews) : null,\n        course_type: courseType,\n        key_skills: row.key_skills || null,\n        modules: row.modules || null,\n        instructors: row.instructors || null,\n        effort: row.effort || null,\n        languages: row.languages || null,\n        price: row.free_trial || undefined,\n        source: String(row.source || \"\"),\n        signup_enabled: Boolean((_row_signup_enabled = row.signup_enabled) !== null && _row_signup_enabled !== void 0 ? _row_signup_enabled : true),\n        is_featured: Boolean((_row_is_featured = row.is_featured) !== null && _row_is_featured !== void 0 ? _row_is_featured : false),\n        price_label: row.price_label || null,\n        free_trial: row.free_trial || null,\n        created_at: row.created_at || null,\n        updated_at: row.updated_at || null\n    };\n}\n/**\n * Raw query - just get everything, no filters\n */ async function rawQueryAllCourses() {\n    try {\n        console.log(\"\\uD83D\\uDD0D RAW QUERY: Fetching ALL courses with no filters...\");\n        // Log the Supabase URL being used (first 30 chars for security)\n        const supabaseUrl = \"https://ktqjebihzkbhsvbqpbui.supabase.co\" || 0;\n        console.log(\"\\uD83D\\uDD17 Supabase URL:\", supabaseUrl ? supabaseUrl.substring(0, 30) + \"...\" : \"❌ MISSING\");\n        console.log(\"\\uD83D\\uDD11 Anon Key:\",  true ? \"✅ Set\" : 0);\n        // Try the simplest possible query first\n        const { data, error, count } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\", {\n            count: \"exact\"\n        }).limit(100) // Add explicit limit\n        ;\n        if (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ RAW QUERY ERROR:\", error);\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            console.error(\"Error hint:\", error.hint);\n            console.error(\"Full error:\", JSON.stringify(error, null, 2));\n            // If it's an RLS error, provide helpful message\n            if (error.code === \"PGRST301\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"permission\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"policy\"))) {\n                console.error(\"\\uD83D\\uDD12 RLS ERROR: Row Level Security is blocking the query!\");\n                console.error(\"Check your Supabase RLS policies for the courses table.\");\n                console.error(\"Go to Supabase Dashboard → Authentication → Policies → courses table\");\n                console.error('Make sure \"courses_select_public\" policy exists and allows SELECT');\n            }\n            return [];\n        }\n        console.log(\"✅ RAW QUERY SUCCESS: Found \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses (count: \").concat(count, \")\"));\n        if (data && data.length > 0) {\n            console.log(\"\\uD83D\\uDCCB Sample raw course data:\", JSON.stringify(data[0], null, 2));\n            console.log(\"\\uD83D\\uDCCB All column names:\", Object.keys(data[0]));\n            console.log(\"\\uD83D\\uDCCB Sample tag value:\", data[0].tag);\n            console.log(\"\\uD83D\\uDCCB Sample priority value:\", data[0].priority);\n        } else {\n            console.warn(\"⚠️ No courses found in database\");\n            console.warn(\"This could mean:\");\n            console.warn(\"1. No courses exist in THIS Supabase project\");\n            console.warn(\"2. RLS policies are blocking the query (but no error shown)\");\n            console.warn(\"3. Wrong Supabase project/credentials\");\n            console.warn(\"\");\n            console.warn(\"\\uD83D\\uDD0D VERIFICATION STEPS:\");\n            console.warn(\"1. Go to Supabase Dashboard → Table Editor → courses\");\n            console.warn(\"2. Check if courses exist there\");\n            console.warn(\"3. Verify the Supabase URL matches:\", supabaseUrl.substring(0, 30) + \"...\");\n            console.warn(\"4. Check RLS policies: Dashboard → Authentication → Policies\");\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"❌ RAW QUERY EXCEPTION:\", error);\n        console.error(\"Exception message:\", error === null || error === void 0 ? void 0 : error.message);\n        console.error(\"Exception stack:\", error === null || error === void 0 ? void 0 : error.stack);\n        return [];\n    }\n}\n/**\n * Test Supabase connection with raw query\n */ async function testSupabaseConnection() {\n    console.log(\"\\uD83E\\uDDEA === TESTING SUPABASE CONNECTION ===\");\n    console.log(\"Supabase URL:\",  true ? \"✅ Set\" : 0);\n    console.log(\"Supabase Key:\",  true ? \"✅ Set\" : 0);\n    const courses = await rawQueryAllCourses();\n    console.log(\"\\uD83D\\uDCCA Connection test result: \".concat(courses.length, \" courses found\"));\n    if (courses.length > 0) {\n        const sample = courses[0];\n        console.log(\"\\uD83D\\uDCCB Sample course columns:\", Object.keys(sample));\n        console.log(\"\\uD83D\\uDCCB Sample course tag value:\", sample.tag);\n        console.log(\"\\uD83D\\uDCCB Sample course type column:\", sample.type || sample.course_type || \"NOT FOUND\");\n    }\n}\n/**\n * Fetches ALL courses - simplest possible query\n */ async function getAllCourses() {\n    try {\n        console.log(\"\\uD83D\\uDCE6 getAllCourses: Starting...\");\n        const rawCourses = await rawQueryAllCourses();\n        if (rawCourses.length === 0) {\n            console.warn(\"⚠️ getAllCourses: No courses found in database\");\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCE6 getAllCourses: Transforming \".concat(rawCourses.length, \" courses...\"));\n        const transformed = rawCourses.map(transformCourse);\n        if (transformed.length > 0) {\n            console.log(\"✅ getAllCourses: Sample transformed course:\", {\n                id: transformed[0].id,\n                title: transformed[0].title,\n                tag: transformed[0].tags,\n                priority: transformed[0].priority\n            });\n        }\n        return transformed;\n    } catch (error) {\n        console.error(\"❌ getAllCourses ERROR:\", error);\n        return [];\n    }\n}\n/**\n * Helper function to get the relevancy column name for a given tag\n */ function getRelevancyColumn(tag) {\n    return tag === \"Business\" ? \"business_relevancy\" : tag === \"Restaurant\" ? \"restaurant_relevancy\" : \"fleet_relevancy\";\n}\n/**\n * Base internal function - fetches courses with flexible options\n * This is the single source of truth for course fetching logic\n * Returns courses with relevancy data preserved (even though Course type doesn't include it)\n */ async function getCoursesByTagInternal(tag) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const { includeHidden = false, limit } = options;\n        const relevancyColumn = getRelevancyColumn(tag);\n        console.log('\\uD83C\\uDFF7️ getCoursesByTagInternal: Fetching courses for tag \"'.concat(tag, '\" (includeHidden: ').concat(includeHidden, \", limit: \").concat(limit || \"none\", \")...\"));\n        console.log('\\uD83C\\uDFF7️ IMPORTANT: NO signup_enabled filter - getting ALL courses for tag \"'.concat(tag, '\"'));\n        console.log(\"\\uD83C\\uDFF7️ Ordering by: \".concat(relevancyColumn, \" (ascending, nullsLast)\"));\n        // Build query step by step - Supabase queries are chainable\n        // CRITICAL: NO FILTERING BY signup_enabled - just get all courses for the tag, sorted by relevancy\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n        // NO .eq('signup_enabled', true) - we want ALL courses regardless of signup_enabled\n        // Order by relevancy column (lower number = higher priority)\n        query = query.order(relevancyColumn || \"priority\", {\n            ascending: true,\n            nullsLast: true\n        });\n        // Apply limit AFTER ordering to ensure we get the top N courses\n        if (limit) {\n            query = query.limit(limit);\n            console.log(\"\\uD83C\\uDFF7️ Limiting to \".concat(limit, \" courses\"));\n        }\n        const { data, error } = await query;\n        // Log the actual results to debug\n        console.log(\"\\uD83C\\uDFF7️ Query executed: returned \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses (limit was \").concat(limit || \"none\", \")\"));\n        if (data && limit && data.length > limit) {\n            console.error(\"❌ ERROR: Query returned \".concat(data.length, \" courses but limit was \").concat(limit, \"! This should not happen.\"));\n        }\n        if (error) {\n            console.error(\"❌ getCoursesByTagInternal DATABASE ERROR:\", error);\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            // Fallback: try using priority if relevancy column doesn't exist\n            console.warn(\"⚠️ Falling back to priority-based ordering...\");\n            let fallbackQuery = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n            fallbackQuery = fallbackQuery.order(\"priority\", {\n                ascending: true,\n                nullsLast: true\n            });\n            if (limit) {\n                fallbackQuery = fallbackQuery.limit(limit);\n            }\n            const { data: fallbackData, error: fallbackError } = await fallbackQuery;\n            if (fallbackError) {\n                console.error(\"❌ Fallback query also failed:\", fallbackError);\n                return [];\n            }\n            const transformed = (fallbackData || []).map(transformCourse);\n            console.log(\"\\uD83C\\uDFF7️ getCoursesByTagInternal (fallback): Returned \".concat(transformed.length, \" courses\"));\n            return transformed;\n        }\n        if (!data || data.length === 0) {\n            console.warn('⚠️ getCoursesByTagInternal: No courses found for tag \"'.concat(tag, '\"'));\n            return [];\n        }\n        // Transform courses - relevancy data exists in raw rows but Course type doesn't include it\n        // The calling code can access it via type assertion if needed (CourseWithRelevancy)\n        let transformed = data.map(transformCourse);\n        // CRITICAL: Enforce limit in case database returns more than requested\n        // This ensures we NEVER return more courses than the limit\n        if (limit && transformed.length > limit) {\n            console.warn(\"⚠️ WARNING: Database returned \".concat(transformed.length, \" courses but limit is \").concat(limit, \". Truncating to \").concat(limit, \".\"));\n            transformed = transformed.slice(0, limit);\n        }\n        console.log(\"\\uD83C\\uDFF7️ getCoursesByTagInternal: Successfully returned \".concat(transformed.length, ' courses for tag \"').concat(tag, '\" (limit was ').concat(limit || \"none\", \")\"));\n        return transformed;\n    } catch (error) {\n        console.error(\"❌ getCoursesByTagInternal EXCEPTION:\", error);\n        console.error(\"Exception message:\", error === null || error === void 0 ? void 0 : error.message);\n        return [];\n    }\n}\n/**\n * For course pages - returns exactly 10 courses sorted by relevancy (no signup_enabled filter)\n */ async function getCoursesByTag(tag) {\n    return getCoursesByTagInternal(tag, {\n        includeHidden: true,\n        limit: 10\n    });\n}\n/**\n * For admin management - returns courses with relevancy data preserved\n * This ensures the management tool shows exactly what course pages display\n */ async function getCoursesByTagWithRelevancy(tag) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { includeHidden = false, limit = 10 } = options;\n    const relevancyColumn = getRelevancyColumn(tag);\n    try {\n        console.log('\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy: Fetching courses for tag \"'.concat(tag, '\" with relevancy data...'));\n        // Build query - same logic as getCoursesByTagInternal but preserve relevancy data\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n        if (!includeHidden) {\n            query = query.eq(\"signup_enabled\", true);\n        }\n        query = query.order(relevancyColumn || \"priority\", {\n            ascending: true,\n            nullsLast: true\n        });\n        if (limit) {\n            query = query.limit(limit);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error(\"❌ getCoursesByTagWithRelevancy DATABASE ERROR:\", error);\n            // Fallback to priority-based ordering\n            let fallbackQuery = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n            if (!includeHidden) {\n                fallbackQuery = fallbackQuery.eq(\"signup_enabled\", true);\n            }\n            fallbackQuery = fallbackQuery.order(\"priority\", {\n                ascending: true,\n                nullsLast: true\n            });\n            if (limit) {\n                fallbackQuery = fallbackQuery.limit(limit);\n            }\n            const { data: fallbackData, error: fallbackError } = await fallbackQuery;\n            if (fallbackError) {\n                console.error(\"❌ Fallback query also failed:\", fallbackError);\n                return [];\n            }\n            // Transform with relevancy data preserved\n            const coursesWithRelevancy = (fallbackData || []).map((row)=>{\n                var _row_business_relevancy, _row_restaurant_relevancy, _row_fleet_relevancy;\n                return {\n                    ...transformCourse(row),\n                    business_relevancy: (_row_business_relevancy = row.business_relevancy) !== null && _row_business_relevancy !== void 0 ? _row_business_relevancy : null,\n                    restaurant_relevancy: (_row_restaurant_relevancy = row.restaurant_relevancy) !== null && _row_restaurant_relevancy !== void 0 ? _row_restaurant_relevancy : null,\n                    fleet_relevancy: (_row_fleet_relevancy = row.fleet_relevancy) !== null && _row_fleet_relevancy !== void 0 ? _row_fleet_relevancy : null\n                };\n            });\n            // Enforce limit\n            const result = limit && coursesWithRelevancy.length > limit ? coursesWithRelevancy.slice(0, limit) : coursesWithRelevancy;\n            console.log(\"\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy (fallback): Returned \".concat(result.length, \" courses\"));\n            return result;\n        }\n        if (!data || data.length === 0) {\n            console.warn('⚠️ getCoursesByTagWithRelevancy: No courses found for tag \"'.concat(tag, '\"'));\n            return [];\n        }\n        // Transform courses and PRESERVE relevancy data from raw database rows\n        // This maintains the exact order from the database query\n        let coursesWithRelevancy = data.map((row)=>{\n            var _row_business_relevancy, _row_restaurant_relevancy, _row_fleet_relevancy;\n            return {\n                ...transformCourse(row),\n                business_relevancy: (_row_business_relevancy = row.business_relevancy) !== null && _row_business_relevancy !== void 0 ? _row_business_relevancy : null,\n                restaurant_relevancy: (_row_restaurant_relevancy = row.restaurant_relevancy) !== null && _row_restaurant_relevancy !== void 0 ? _row_restaurant_relevancy : null,\n                fleet_relevancy: (_row_fleet_relevancy = row.fleet_relevancy) !== null && _row_fleet_relevancy !== void 0 ? _row_fleet_relevancy : null\n            };\n        });\n        // Enforce limit\n        if (limit && coursesWithRelevancy.length > limit) {\n            console.warn(\"⚠️ WARNING: Database returned \".concat(coursesWithRelevancy.length, \" courses but limit is \").concat(limit, \". Truncating to \").concat(limit, \".\"));\n            coursesWithRelevancy = coursesWithRelevancy.slice(0, limit);\n        }\n        console.log(\"\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy: Successfully returned \".concat(coursesWithRelevancy.length, ' courses for tag \"').concat(tag, '\"'));\n        return coursesWithRelevancy;\n    } catch (error) {\n        console.error(\"❌ getCoursesByTagWithRelevancy EXCEPTION:\", error);\n        return [];\n    }\n}\n/**\n * For admin management - returns all courses (visible + hidden) for management\n */ async function getCoursesByTagForManagement(tag) {\n    return getCoursesByTagInternal(tag, {\n        includeHidden: true,\n        limit: 100\n    });\n}\n/**\n * Fetches a single course by ID\n */ async function getCourseById(id) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCourseById: Fetching course \".concat(id, \"...\"));\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"id\", id).maybeSingle();\n        if (error) {\n            console.error(\"❌ getCourseById ERROR:\", error);\n            return null;\n        }\n        if (!data) {\n            console.warn(\"⚠️ getCourseById: Course \".concat(id, \" not found\"));\n            return null;\n        }\n        console.log(\"✅ getCourseById: Found course \".concat(id));\n        return transformCourse(data);\n    } catch (error) {\n        console.error(\"❌ getCourseById EXCEPTION:\", error);\n        return null;\n    }\n}\n/**\n * Fetches featured courses - directly queries database with is_featured filter\n * This is more efficient than fetching all courses and filtering in memory\n */ async function getFeaturedCourses() {\n    try {\n        console.log(\"⭐ getFeaturedCourses: Fetching featured courses from database...\");\n        // Query database directly for featured courses\n        // Only show courses where signup_enabled is true (visible courses)\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"is_featured\", true).eq(\"signup_enabled\", true).order(\"priority\", {\n            ascending: true,\n            nullsFirst: false\n        });\n        if (error) {\n            console.error(\"❌ getFeaturedCourses DATABASE ERROR:\", error);\n            return [];\n        }\n        if (!data || data.length === 0) {\n            console.log(\"⭐ getFeaturedCourses: No featured courses found\");\n            return [];\n        }\n        console.log(\"⭐ getFeaturedCourses: Database returned \".concat(data.length, \" featured courses\"));\n        // Transform database rows to Course objects\n        const featured = data.map(transformCourse);\n        console.log(\"⭐ getFeaturedCourses: Successfully returned \".concat(featured.length, \" featured courses\"));\n        return featured;\n    } catch (error) {\n        console.error(\"❌ getFeaturedCourses ERROR:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUM7UUFFbkUsNENBQTRDO1FBQzVDLE1BQU1zQyxXQUFXbEQsS0FBS3VCLEdBQUcsQ0FBQ3RFO1FBRTFCdUMsUUFBUUMsR0FBRyxDQUFDLCtDQUErRCxPQUFoQnlELFNBQVN0QyxNQUFNLEVBQUM7UUFDM0UsT0FBT3NDO0lBQ1QsRUFBRSxPQUFPakQsT0FBTztRQUNkVCxRQUFRUyxLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxPQUFPLEVBQUU7SUFDWDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9kYXRhL2NvdXJzZXMudHM/N2NiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuaW1wb3J0IHsgQ291cnNlLCBDb3Vyc2VUYWcsIERhdGFiYXNlQ291cnNlIH0gZnJvbSAnQC90eXBlcy9jb3Vyc2UnXG5cbi8qKlxuICogUmF3IGRhdGFiYXNlIHJvdyB0eXBlIC0gYWNjZXB0cyBhbnkgY29sdW1uIG5hbWUgdmFyaWF0aW9uc1xuICovXG50eXBlIFJhd0NvdXJzZVJvdyA9IFJlY29yZDxzdHJpbmcsIGFueT5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gZnVuY3Rpb24gLSBoYW5kbGVzIGJvdGggJ2NvdXJzZV90eXBlJyBhbmQgJ3R5cGUnIGNvbHVtbiBuYW1lc1xuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Db3Vyc2Uocm93OiBSYXdDb3Vyc2VSb3cpOiBDb3Vyc2Uge1xuICAvLyBIYW5kbGUgYm90aCAnY291cnNlX3R5cGUnIGFuZCAndHlwZScgY29sdW1uIG5hbWVzXG4gIGNvbnN0IGNvdXJzZVR5cGUgPSByb3cudHlwZSB8fCByb3cuY291cnNlX3R5cGUgfHwgbnVsbFxuICBcbiAgcmV0dXJuIHtcbiAgICBpZDogU3RyaW5nKHJvdy5pZCB8fCAnJyksXG4gICAgdGl0bGU6IFN0cmluZyhyb3cudGl0bGUgfHwgJycpLFxuICAgIGRlc2NyaXB0aW9uOiBTdHJpbmcocm93LmRlc2NyaXB0aW9uIHx8ICcnKSxcbiAgICBoZWFkbGluZTogcm93LmhlYWRsaW5lIHx8IG51bGwsXG4gICAgYnVsbGV0X3BvaW50czogQXJyYXkuaXNBcnJheShyb3cuYnVsbGV0X3BvaW50cykgPyByb3cuYnVsbGV0X3BvaW50cyA6IG51bGwsXG4gICAgcHJvdmlkZXI6IHJvdy5wcm92aWRlciB8fCBudWxsLFxuICAgIGxldmVsOiAocm93LmxldmVsIGFzIGFueSkgfHwgJ0JlZ2lubmVyJyxcbiAgICBkdXJhdGlvbjogU3RyaW5nKHJvdy5kdXJhdGlvbiB8fCAnJyksXG4gICAgdGFnczogcm93LnRhZyA/IFtyb3cudGFnXSA6IFtdLFxuICAgIGV4dGVybmFsX3VybDogcm93LmV4dGVybmFsX3VybCB8fCBudWxsLFxuICAgIHByaW9yaXR5OiBOdW1iZXIocm93LnByaW9yaXR5KSB8fCA5OTksXG4gICAgcmF0aW5nOiByb3cucmF0aW5nID8gTnVtYmVyKHJvdy5yYXRpbmcpIDogbnVsbCxcbiAgICByZXZpZXdzOiByb3cucmV2aWV3cyA/IE51bWJlcihyb3cucmV2aWV3cykgOiBudWxsLFxuICAgIGNvdXJzZV90eXBlOiBjb3Vyc2VUeXBlLFxuICAgIGtleV9za2lsbHM6IHJvdy5rZXlfc2tpbGxzIHx8IG51bGwsXG4gICAgbW9kdWxlczogcm93Lm1vZHVsZXMgfHwgbnVsbCxcbiAgICBpbnN0cnVjdG9yczogcm93Lmluc3RydWN0b3JzIHx8IG51bGwsXG4gICAgZWZmb3J0OiByb3cuZWZmb3J0IHx8IG51bGwsXG4gICAgbGFuZ3VhZ2VzOiByb3cubGFuZ3VhZ2VzIHx8IG51bGwsXG4gICAgcHJpY2U6IHJvdy5mcmVlX3RyaWFsIHx8IHVuZGVmaW5lZCxcbiAgICBzb3VyY2U6IFN0cmluZyhyb3cuc291cmNlIHx8ICcnKSxcbiAgICBzaWdudXBfZW5hYmxlZDogQm9vbGVhbihyb3cuc2lnbnVwX2VuYWJsZWQgPz8gdHJ1ZSksXG4gICAgaXNfZmVhdHVyZWQ6IEJvb2xlYW4ocm93LmlzX2ZlYXR1cmVkID8/IGZhbHNlKSxcbiAgICBwcmljZV9sYWJlbDogcm93LnByaWNlX2xhYmVsIHx8IG51bGwsXG4gICAgZnJlZV90cmlhbDogcm93LmZyZWVfdHJpYWwgfHwgbnVsbCxcbiAgICBjcmVhdGVkX2F0OiByb3cuY3JlYXRlZF9hdCB8fCBudWxsLFxuICAgIHVwZGF0ZWRfYXQ6IHJvdy51cGRhdGVkX2F0IHx8IG51bGwsXG4gIH1cbn1cblxuLyoqXG4gKiBSYXcgcXVlcnkgLSBqdXN0IGdldCBldmVyeXRoaW5nLCBubyBmaWx0ZXJzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJhd1F1ZXJ5QWxsQ291cnNlcygpOiBQcm9taXNlPFJhd0NvdXJzZVJvd1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gUkFXIFFVRVJZOiBGZXRjaGluZyBBTEwgY291cnNlcyB3aXRoIG5vIGZpbHRlcnMuLi4nKVxuICAgIFxuICAgIC8vIExvZyB0aGUgU3VwYWJhc2UgVVJMIGJlaW5nIHVzZWQgKGZpcnN0IDMwIGNoYXJzIGZvciBzZWN1cml0eSlcbiAgICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCB8fCAnJ1xuICAgIGNvbnNvbGUubG9nKCfwn5SXIFN1cGFiYXNlIFVSTDonLCBzdXBhYmFzZVVybCA/IHN1cGFiYXNlVXJsLnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJyA6ICfinYwgTUlTU0lORycpXG4gICAgY29uc29sZS5sb2coJ/CflJEgQW5vbiBLZXk6JywgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPyAn4pyFIFNldCcgOiAn4p2MIE1JU1NJTkcnKVxuICAgIFxuICAgIC8vIFRyeSB0aGUgc2ltcGxlc3QgcG9zc2libGUgcXVlcnkgZmlyc3RcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnIH0pXG4gICAgICAubGltaXQoMTAwKSAvLyBBZGQgZXhwbGljaXQgbGltaXRcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFJBVyBRVUVSWSBFUlJPUjonLCBlcnJvcilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhpbnQ6JywgZXJyb3IuaGludClcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bGwgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxuICAgICAgXG4gICAgICAvLyBJZiBpdCdzIGFuIFJMUyBlcnJvciwgcHJvdmlkZSBoZWxwZnVsIG1lc3NhZ2VcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnUEdSU1QzMDEnIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdwZXJtaXNzaW9uJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3BvbGljeScpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CflJIgUkxTIEVSUk9SOiBSb3cgTGV2ZWwgU2VjdXJpdHkgaXMgYmxvY2tpbmcgdGhlIHF1ZXJ5IScpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NoZWNrIHlvdXIgU3VwYWJhc2UgUkxTIHBvbGljaWVzIGZvciB0aGUgY291cnNlcyB0YWJsZS4nKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdHbyB0byBTdXBhYmFzZSBEYXNoYm9hcmQg4oaSIEF1dGhlbnRpY2F0aW9uIOKGkiBQb2xpY2llcyDihpIgY291cnNlcyB0YWJsZScpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01ha2Ugc3VyZSBcImNvdXJzZXNfc2VsZWN0X3B1YmxpY1wiIHBvbGljeSBleGlzdHMgYW5kIGFsbG93cyBTRUxFQ1QnKVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg4pyFIFJBVyBRVUVSWSBTVUNDRVNTOiBGb3VuZCAke2RhdGE/Lmxlbmd0aCB8fCAwfSBjb3Vyc2VzIChjb3VudDogJHtjb3VudH0pYClcbiAgICBcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIFNhbXBsZSByYXcgY291cnNlIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkoZGF0YVswXSwgbnVsbCwgMikpXG4gICAgICBjb25zb2xlLmxvZygn8J+TiyBBbGwgY29sdW1uIG5hbWVzOicsIE9iamVjdC5rZXlzKGRhdGFbMF0pKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4sgU2FtcGxlIHRhZyB2YWx1ZTonLCBkYXRhWzBdLnRhZylcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIFNhbXBsZSBwcmlvcml0eSB2YWx1ZTonLCBkYXRhWzBdLnByaW9yaXR5KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBjb3Vyc2VzIGZvdW5kIGluIGRhdGFiYXNlJylcbiAgICAgIGNvbnNvbGUud2FybignVGhpcyBjb3VsZCBtZWFuOicpXG4gICAgICBjb25zb2xlLndhcm4oJzEuIE5vIGNvdXJzZXMgZXhpc3QgaW4gVEhJUyBTdXBhYmFzZSBwcm9qZWN0JylcbiAgICAgIGNvbnNvbGUud2FybignMi4gUkxTIHBvbGljaWVzIGFyZSBibG9ja2luZyB0aGUgcXVlcnkgKGJ1dCBubyBlcnJvciBzaG93biknKVxuICAgICAgY29uc29sZS53YXJuKCczLiBXcm9uZyBTdXBhYmFzZSBwcm9qZWN0L2NyZWRlbnRpYWxzJylcbiAgICAgIGNvbnNvbGUud2FybignJylcbiAgICAgIGNvbnNvbGUud2Fybign8J+UjSBWRVJJRklDQVRJT04gU1RFUFM6JylcbiAgICAgIGNvbnNvbGUud2FybignMS4gR28gdG8gU3VwYWJhc2UgRGFzaGJvYXJkIOKGkiBUYWJsZSBFZGl0b3Ig4oaSIGNvdXJzZXMnKVxuICAgICAgY29uc29sZS53YXJuKCcyLiBDaGVjayBpZiBjb3Vyc2VzIGV4aXN0IHRoZXJlJylcbiAgICAgIGNvbnNvbGUud2FybignMy4gVmVyaWZ5IHRoZSBTdXBhYmFzZSBVUkwgbWF0Y2hlczonLCBzdXBhYmFzZVVybC5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicpXG4gICAgICBjb25zb2xlLndhcm4oJzQuIENoZWNrIFJMUyBwb2xpY2llczogRGFzaGJvYXJkIOKGkiBBdXRoZW50aWNhdGlvbiDihpIgUG9saWNpZXMnKVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgUkFXIFFVRVJZIEVYQ0VQVElPTjonLCBlcnJvcilcbiAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gbWVzc2FnZTonLCBlcnJvcj8ubWVzc2FnZSlcbiAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gc3RhY2s6JywgZXJyb3I/LnN0YWNrKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8qKlxuICogVGVzdCBTdXBhYmFzZSBjb25uZWN0aW9uIHdpdGggcmF3IHF1ZXJ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXN0U3VwYWJhc2VDb25uZWN0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zb2xlLmxvZygn8J+nqiA9PT0gVEVTVElORyBTVVBBQkFTRSBDT05ORUNUSU9OID09PScpXG4gIGNvbnNvbGUubG9nKCdTdXBhYmFzZSBVUkw6JywgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID8gJ+KchSBTZXQnIDogJ+KdjCBNaXNzaW5nJylcbiAgY29uc29sZS5sb2coJ1N1cGFiYXNlIEtleTonLCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSA/ICfinIUgU2V0JyA6ICfinYwgTWlzc2luZycpXG4gIFxuICBjb25zdCBjb3Vyc2VzID0gYXdhaXQgcmF3UXVlcnlBbGxDb3Vyc2VzKClcbiAgY29uc29sZS5sb2coYPCfk4ogQ29ubmVjdGlvbiB0ZXN0IHJlc3VsdDogJHtjb3Vyc2VzLmxlbmd0aH0gY291cnNlcyBmb3VuZGApXG4gIFxuICBpZiAoY291cnNlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc2FtcGxlID0gY291cnNlc1swXVxuICAgIGNvbnNvbGUubG9nKCfwn5OLIFNhbXBsZSBjb3Vyc2UgY29sdW1uczonLCBPYmplY3Qua2V5cyhzYW1wbGUpKVxuICAgIGNvbnNvbGUubG9nKCfwn5OLIFNhbXBsZSBjb3Vyc2UgdGFnIHZhbHVlOicsIHNhbXBsZS50YWcpXG4gICAgY29uc29sZS5sb2coJ/Cfk4sgU2FtcGxlIGNvdXJzZSB0eXBlIGNvbHVtbjonLCBzYW1wbGUudHlwZSB8fCBzYW1wbGUuY291cnNlX3R5cGUgfHwgJ05PVCBGT1VORCcpXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIEFMTCBjb3Vyc2VzIC0gc2ltcGxlc3QgcG9zc2libGUgcXVlcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbENvdXJzZXMoKTogUHJvbWlzZTxDb3Vyc2VbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5OmIGdldEFsbENvdXJzZXM6IFN0YXJ0aW5nLi4uJylcbiAgICBcbiAgICBjb25zdCByYXdDb3Vyc2VzID0gYXdhaXQgcmF3UXVlcnlBbGxDb3Vyc2VzKClcbiAgICBcbiAgICBpZiAocmF3Q291cnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIGdldEFsbENvdXJzZXM6IE5vIGNvdXJzZXMgZm91bmQgaW4gZGF0YWJhc2UnKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYPCfk6YgZ2V0QWxsQ291cnNlczogVHJhbnNmb3JtaW5nICR7cmF3Q291cnNlcy5sZW5ndGh9IGNvdXJzZXMuLi5gKVxuICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gcmF3Q291cnNlcy5tYXAodHJhbnNmb3JtQ291cnNlKVxuICAgIFxuICAgIGlmICh0cmFuc2Zvcm1lZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIGdldEFsbENvdXJzZXM6IFNhbXBsZSB0cmFuc2Zvcm1lZCBjb3Vyc2U6Jywge1xuICAgICAgICBpZDogdHJhbnNmb3JtZWRbMF0uaWQsXG4gICAgICAgIHRpdGxlOiB0cmFuc2Zvcm1lZFswXS50aXRsZSxcbiAgICAgICAgdGFnOiB0cmFuc2Zvcm1lZFswXS50YWdzLFxuICAgICAgICBwcmlvcml0eTogdHJhbnNmb3JtZWRbMF0ucHJpb3JpdHksXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2Zvcm1lZFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRBbGxDb3Vyc2VzIEVSUk9SOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgcmVsZXZhbmN5IGNvbHVtbiBuYW1lIGZvciBhIGdpdmVuIHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsZXZhbmN5Q29sdW1uKHRhZzogQ291cnNlVGFnKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ0J1c2luZXNzJyBcbiAgICA/ICdidXNpbmVzc19yZWxldmFuY3knIFxuICAgIDogdGFnID09PSAnUmVzdGF1cmFudCcgXG4gICAgPyAncmVzdGF1cmFudF9yZWxldmFuY3knIFxuICAgIDogJ2ZsZWV0X3JlbGV2YW5jeSdcbn1cblxuLyoqXG4gKiBCYXNlIGludGVybmFsIGZ1bmN0aW9uIC0gZmV0Y2hlcyBjb3Vyc2VzIHdpdGggZmxleGlibGUgb3B0aW9uc1xuICogVGhpcyBpcyB0aGUgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgY291cnNlIGZldGNoaW5nIGxvZ2ljXG4gKiBSZXR1cm5zIGNvdXJzZXMgd2l0aCByZWxldmFuY3kgZGF0YSBwcmVzZXJ2ZWQgKGV2ZW4gdGhvdWdoIENvdXJzZSB0eXBlIGRvZXNuJ3QgaW5jbHVkZSBpdClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwoXG4gIHRhZzogQ291cnNlVGFnLCBcbiAgb3B0aW9uczoge1xuICAgIGluY2x1ZGVIaWRkZW4/OiBib29sZWFuXG4gICAgbGltaXQ/OiBudW1iZXJcbiAgfSA9IHt9XG4pOiBQcm9taXNlPENvdXJzZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBpbmNsdWRlSGlkZGVuID0gZmFsc2UsIGxpbWl0IH0gPSBvcHRpb25zXG4gICAgY29uc3QgcmVsZXZhbmN5Q29sdW1uID0gZ2V0UmVsZXZhbmN5Q29sdW1uKHRhZylcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbDogRmV0Y2hpbmcgY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCIgKGluY2x1ZGVIaWRkZW46ICR7aW5jbHVkZUhpZGRlbn0sIGxpbWl0OiAke2xpbWl0IHx8ICdub25lJ30pLi4uYClcbiAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBJTVBPUlRBTlQ6IE5PIHNpZ251cF9lbmFibGVkIGZpbHRlciAtIGdldHRpbmcgQUxMIGNvdXJzZXMgZm9yIHRhZyBcIiR7dGFnfVwiYClcbiAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBPcmRlcmluZyBieTogJHtyZWxldmFuY3lDb2x1bW59IChhc2NlbmRpbmcsIG51bGxzTGFzdClgKVxuICAgIFxuICAgIC8vIEJ1aWxkIHF1ZXJ5IHN0ZXAgYnkgc3RlcCAtIFN1cGFiYXNlIHF1ZXJpZXMgYXJlIGNoYWluYWJsZVxuICAgIC8vIENSSVRJQ0FMOiBOTyBGSUxURVJJTkcgQlkgc2lnbnVwX2VuYWJsZWQgLSBqdXN0IGdldCBhbGwgY291cnNlcyBmb3IgdGhlIHRhZywgc29ydGVkIGJ5IHJlbGV2YW5jeVxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgICAgLy8gTk8gLmVxKCdzaWdudXBfZW5hYmxlZCcsIHRydWUpIC0gd2Ugd2FudCBBTEwgY291cnNlcyByZWdhcmRsZXNzIG9mIHNpZ251cF9lbmFibGVkXG4gICAgXG4gICAgLy8gT3JkZXIgYnkgcmVsZXZhbmN5IGNvbHVtbiAobG93ZXIgbnVtYmVyID0gaGlnaGVyIHByaW9yaXR5KVxuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIocmVsZXZhbmN5Q29sdW1uIHx8ICdwcmlvcml0eScsIHsgYXNjZW5kaW5nOiB0cnVlLCBudWxsc0xhc3Q6IHRydWUgfSlcbiAgICBcbiAgICAvLyBBcHBseSBsaW1pdCBBRlRFUiBvcmRlcmluZyB0byBlbnN1cmUgd2UgZ2V0IHRoZSB0b3AgTiBjb3Vyc2VzXG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmxpbWl0KGxpbWl0KVxuICAgICAgY29uc29sZS5sb2coYPCfj7fvuI8gTGltaXRpbmcgdG8gJHtsaW1pdH0gY291cnNlc2ApXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XG4gICAgXG4gICAgLy8gTG9nIHRoZSBhY3R1YWwgcmVzdWx0cyB0byBkZWJ1Z1xuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIFF1ZXJ5IGV4ZWN1dGVkOiByZXR1cm5lZCAke2RhdGE/Lmxlbmd0aCB8fCAwfSBjb3Vyc2VzIChsaW1pdCB3YXMgJHtsaW1pdCB8fCAnbm9uZSd9KWApXG4gICAgaWYgKGRhdGEgJiYgbGltaXQgJiYgZGF0YS5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVSUk9SOiBRdWVyeSByZXR1cm5lZCAke2RhdGEubGVuZ3RofSBjb3Vyc2VzIGJ1dCBsaW1pdCB3YXMgJHtsaW1pdH0hIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uYClcbiAgICB9XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwgREFUQUJBU0UgRVJST1I6JywgZXJyb3IpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrOiB0cnkgdXNpbmcgcHJpb3JpdHkgaWYgcmVsZXZhbmN5IGNvbHVtbiBkb2Vzbid0IGV4aXN0XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBGYWxsaW5nIGJhY2sgdG8gcHJpb3JpdHktYmFzZWQgb3JkZXJpbmcuLi4nKVxuICAgICAgbGV0IGZhbGxiYWNrUXVlcnkgPSBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3RhZycsIHRhZylcbiAgICAgIFxuICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkub3JkZXIoJ3ByaW9yaXR5JywgeyBhc2NlbmRpbmc6IHRydWUsIG51bGxzTGFzdDogdHJ1ZSB9KVxuICAgICAgXG4gICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkubGltaXQobGltaXQpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogZmFsbGJhY2tEYXRhLCBlcnJvcjogZmFsbGJhY2tFcnJvciB9ID0gYXdhaXQgZmFsbGJhY2tRdWVyeVxuICAgICAgXG4gICAgICBpZiAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFsbGJhY2sgcXVlcnkgYWxzbyBmYWlsZWQ6JywgZmFsbGJhY2tFcnJvcilcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gKGZhbGxiYWNrRGF0YSB8fCBbXSkubWFwKHRyYW5zZm9ybUNvdXJzZSlcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+377iPIGdldENvdXJzZXNCeVRhZ0ludGVybmFsIChmYWxsYmFjayk6IFJldHVybmVkICR7dHJhbnNmb3JtZWQubGVuZ3RofSBjb3Vyc2VzYClcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFxuICAgIH1cbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIGdldENvdXJzZXNCeVRhZ0ludGVybmFsOiBObyBjb3Vyc2VzIGZvdW5kIGZvciB0YWcgXCIke3RhZ31cImApXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgXG4gICAgLy8gVHJhbnNmb3JtIGNvdXJzZXMgLSByZWxldmFuY3kgZGF0YSBleGlzdHMgaW4gcmF3IHJvd3MgYnV0IENvdXJzZSB0eXBlIGRvZXNuJ3QgaW5jbHVkZSBpdFxuICAgIC8vIFRoZSBjYWxsaW5nIGNvZGUgY2FuIGFjY2VzcyBpdCB2aWEgdHlwZSBhc3NlcnRpb24gaWYgbmVlZGVkIChDb3Vyc2VXaXRoUmVsZXZhbmN5KVxuICAgIGxldCB0cmFuc2Zvcm1lZCA9IGRhdGEubWFwKHRyYW5zZm9ybUNvdXJzZSlcbiAgICBcbiAgICAvLyBDUklUSUNBTDogRW5mb3JjZSBsaW1pdCBpbiBjYXNlIGRhdGFiYXNlIHJldHVybnMgbW9yZSB0aGFuIHJlcXVlc3RlZFxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBORVZFUiByZXR1cm4gbW9yZSBjb3Vyc2VzIHRoYW4gdGhlIGxpbWl0XG4gICAgaWYgKGxpbWl0ICYmIHRyYW5zZm9ybWVkLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXQVJOSU5HOiBEYXRhYmFzZSByZXR1cm5lZCAke3RyYW5zZm9ybWVkLmxlbmd0aH0gY291cnNlcyBidXQgbGltaXQgaXMgJHtsaW1pdH0uIFRydW5jYXRpbmcgdG8gJHtsaW1pdH0uYClcbiAgICAgIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZWQuc2xpY2UoMCwgbGltaXQpXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIGdldENvdXJzZXNCeVRhZ0ludGVybmFsOiBTdWNjZXNzZnVsbHkgcmV0dXJuZWQgJHt0cmFuc2Zvcm1lZC5sZW5ndGh9IGNvdXJzZXMgZm9yIHRhZyBcIiR7dGFnfVwiIChsaW1pdCB3YXMgJHtsaW1pdCB8fCAnbm9uZSd9KWApXG4gICAgXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwgRVhDRVBUSU9OOicsIGVycm9yKVxuICAgIGNvbnNvbGUuZXJyb3IoJ0V4Y2VwdGlvbiBtZXNzYWdlOicsIGVycm9yPy5tZXNzYWdlKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBjb3Vyc2VzIHdpdGggcmVsZXZhbmN5IGRhdGEgKHVzZWQgYnkgYWRtaW4gbWFuYWdlbWVudClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb3Vyc2VXaXRoUmVsZXZhbmN5IGV4dGVuZHMgQ291cnNlIHtcbiAgYnVzaW5lc3NfcmVsZXZhbmN5PzogbnVtYmVyIHwgbnVsbFxuICByZXN0YXVyYW50X3JlbGV2YW5jeT86IG51bWJlciB8IG51bGxcbiAgZmxlZXRfcmVsZXZhbmN5PzogbnVtYmVyIHwgbnVsbFxufVxuXG4vKipcbiAqIEZvciBjb3Vyc2UgcGFnZXMgLSByZXR1cm5zIGV4YWN0bHkgMTAgY291cnNlcyBzb3J0ZWQgYnkgcmVsZXZhbmN5IChubyBzaWdudXBfZW5hYmxlZCBmaWx0ZXIpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VzQnlUYWcodGFnOiBDb3Vyc2VUYWcpOiBQcm9taXNlPENvdXJzZVtdPiB7XG4gIHJldHVybiBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCh0YWcsIHsgaW5jbHVkZUhpZGRlbjogdHJ1ZSwgbGltaXQ6IDEwIH0pXG59XG5cbi8qKlxuICogRm9yIGFkbWluIG1hbmFnZW1lbnQgLSByZXR1cm5zIGNvdXJzZXMgd2l0aCByZWxldmFuY3kgZGF0YSBwcmVzZXJ2ZWRcbiAqIFRoaXMgZW5zdXJlcyB0aGUgbWFuYWdlbWVudCB0b29sIHNob3dzIGV4YWN0bHkgd2hhdCBjb3Vyc2UgcGFnZXMgZGlzcGxheVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlc0J5VGFnV2l0aFJlbGV2YW5jeShcbiAgdGFnOiBDb3Vyc2VUYWcsXG4gIG9wdGlvbnM6IHsgaW5jbHVkZUhpZGRlbj86IGJvb2xlYW47IGxpbWl0PzogbnVtYmVyIH0gPSB7fVxuKTogUHJvbWlzZTxDb3Vyc2VXaXRoUmVsZXZhbmN5W10+IHtcbiAgY29uc3QgeyBpbmNsdWRlSGlkZGVuID0gZmFsc2UsIGxpbWl0ID0gMTAgfSA9IG9wdGlvbnNcbiAgY29uc3QgcmVsZXZhbmN5Q29sdW1uID0gZ2V0UmVsZXZhbmN5Q29sdW1uKHRhZylcbiAgXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnV2l0aFJlbGV2YW5jeTogRmV0Y2hpbmcgY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCIgd2l0aCByZWxldmFuY3kgZGF0YS4uLmApXG4gICAgXG4gICAgLy8gQnVpbGQgcXVlcnkgLSBzYW1lIGxvZ2ljIGFzIGdldENvdXJzZXNCeVRhZ0ludGVybmFsIGJ1dCBwcmVzZXJ2ZSByZWxldmFuY3kgZGF0YVxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgIFxuICAgIGlmICghaW5jbHVkZUhpZGRlbikge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnc2lnbnVwX2VuYWJsZWQnLCB0cnVlKVxuICAgIH1cbiAgICBcbiAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKHJlbGV2YW5jeUNvbHVtbiB8fCAncHJpb3JpdHknLCB7IGFzY2VuZGluZzogdHJ1ZSwgbnVsbHNMYXN0OiB0cnVlIH0pXG4gICAgXG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmxpbWl0KGxpbWl0KVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeVxuICAgIFxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3kgREFUQUJBU0UgRVJST1I6JywgZXJyb3IpXG4gICAgICAvLyBGYWxsYmFjayB0byBwcmlvcml0eS1iYXNlZCBvcmRlcmluZ1xuICAgICAgbGV0IGZhbGxiYWNrUXVlcnkgPSBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ3RhZycsIHRhZylcbiAgICAgIFxuICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuKSB7XG4gICAgICAgIGZhbGxiYWNrUXVlcnkgPSBmYWxsYmFja1F1ZXJ5LmVxKCdzaWdudXBfZW5hYmxlZCcsIHRydWUpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGZhbGxiYWNrUXVlcnkgPSBmYWxsYmFja1F1ZXJ5Lm9yZGVyKCdwcmlvcml0eScsIHsgYXNjZW5kaW5nOiB0cnVlLCBudWxsc0xhc3Q6IHRydWUgfSlcbiAgICAgIFxuICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgIGZhbGxiYWNrUXVlcnkgPSBmYWxsYmFja1F1ZXJ5LmxpbWl0KGxpbWl0KVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IGZhbGxiYWNrRGF0YSwgZXJyb3I6IGZhbGxiYWNrRXJyb3IgfSA9IGF3YWl0IGZhbGxiYWNrUXVlcnlcbiAgICAgIFxuICAgICAgaWYgKGZhbGxiYWNrRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhbGxiYWNrIHF1ZXJ5IGFsc28gZmFpbGVkOicsIGZhbGxiYWNrRXJyb3IpXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcmFuc2Zvcm0gd2l0aCByZWxldmFuY3kgZGF0YSBwcmVzZXJ2ZWRcbiAgICAgIGNvbnN0IGNvdXJzZXNXaXRoUmVsZXZhbmN5ID0gKGZhbGxiYWNrRGF0YSB8fCBbXSkubWFwKHJvdyA9PiAoe1xuICAgICAgICAuLi50cmFuc2Zvcm1Db3Vyc2Uocm93KSxcbiAgICAgICAgYnVzaW5lc3NfcmVsZXZhbmN5OiByb3cuYnVzaW5lc3NfcmVsZXZhbmN5ID8/IG51bGwsXG4gICAgICAgIHJlc3RhdXJhbnRfcmVsZXZhbmN5OiByb3cucmVzdGF1cmFudF9yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgICAgZmxlZXRfcmVsZXZhbmN5OiByb3cuZmxlZXRfcmVsZXZhbmN5ID8/IG51bGwsXG4gICAgICB9KSkgYXMgQ291cnNlV2l0aFJlbGV2YW5jeVtdXG4gICAgICBcbiAgICAgIC8vIEVuZm9yY2UgbGltaXRcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGxpbWl0ICYmIGNvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aCA+IGxpbWl0IFxuICAgICAgICA/IGNvdXJzZXNXaXRoUmVsZXZhbmN5LnNsaWNlKDAsIGxpbWl0KVxuICAgICAgICA6IGNvdXJzZXNXaXRoUmVsZXZhbmN5XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+377iPIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3kgKGZhbGxiYWNrKTogUmV0dXJuZWQgJHtyZXN1bHQubGVuZ3RofSBjb3Vyc2VzYClcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgXG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5OiBObyBjb3Vyc2VzIGZvdW5kIGZvciB0YWcgXCIke3RhZ31cImApXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgXG4gICAgLy8gVHJhbnNmb3JtIGNvdXJzZXMgYW5kIFBSRVNFUlZFIHJlbGV2YW5jeSBkYXRhIGZyb20gcmF3IGRhdGFiYXNlIHJvd3NcbiAgICAvLyBUaGlzIG1haW50YWlucyB0aGUgZXhhY3Qgb3JkZXIgZnJvbSB0aGUgZGF0YWJhc2UgcXVlcnlcbiAgICBsZXQgY291cnNlc1dpdGhSZWxldmFuY3kgPSBkYXRhLm1hcChyb3cgPT4gKHtcbiAgICAgIC4uLnRyYW5zZm9ybUNvdXJzZShyb3cpLFxuICAgICAgYnVzaW5lc3NfcmVsZXZhbmN5OiByb3cuYnVzaW5lc3NfcmVsZXZhbmN5ID8/IG51bGwsXG4gICAgICByZXN0YXVyYW50X3JlbGV2YW5jeTogcm93LnJlc3RhdXJhbnRfcmVsZXZhbmN5ID8/IG51bGwsXG4gICAgICBmbGVldF9yZWxldmFuY3k6IHJvdy5mbGVldF9yZWxldmFuY3kgPz8gbnVsbCxcbiAgICB9KSkgYXMgQ291cnNlV2l0aFJlbGV2YW5jeVtdXG4gICAgXG4gICAgLy8gRW5mb3JjZSBsaW1pdFxuICAgIGlmIChsaW1pdCAmJiBjb3Vyc2VzV2l0aFJlbGV2YW5jeS5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gV0FSTklORzogRGF0YWJhc2UgcmV0dXJuZWQgJHtjb3Vyc2VzV2l0aFJlbGV2YW5jeS5sZW5ndGh9IGNvdXJzZXMgYnV0IGxpbWl0IGlzICR7bGltaXR9LiBUcnVuY2F0aW5nIHRvICR7bGltaXR9LmApXG4gICAgICBjb3Vyc2VzV2l0aFJlbGV2YW5jeSA9IGNvdXJzZXNXaXRoUmVsZXZhbmN5LnNsaWNlKDAsIGxpbWl0KVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5OiBTdWNjZXNzZnVsbHkgcmV0dXJuZWQgJHtjb3Vyc2VzV2l0aFJlbGV2YW5jeS5sZW5ndGh9IGNvdXJzZXMgZm9yIHRhZyBcIiR7dGFnfVwiYClcbiAgICByZXR1cm4gY291cnNlc1dpdGhSZWxldmFuY3lcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5IEVYQ0VQVElPTjonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vKipcbiAqIEZvciBhZG1pbiBtYW5hZ2VtZW50IC0gcmV0dXJucyBhbGwgY291cnNlcyAodmlzaWJsZSArIGhpZGRlbikgZm9yIG1hbmFnZW1lbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZXNCeVRhZ0Zvck1hbmFnZW1lbnQodGFnOiBDb3Vyc2VUYWcpOiBQcm9taXNlPENvdXJzZVtdPiB7XG4gIHJldHVybiBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCh0YWcsIHsgaW5jbHVkZUhpZGRlbjogdHJ1ZSwgbGltaXQ6IDEwMCB9KVxufVxuXG4vKipcbiAqIEZldGNoZXMgYSBzaW5nbGUgY291cnNlIGJ5IElEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPENvdXJzZSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBnZXRDb3Vyc2VCeUlkOiBGZXRjaGluZyBjb3Vyc2UgJHtpZH0uLi5gKVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5tYXliZVNpbmdsZSgpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VCeUlkIEVSUk9SOicsIGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIGdldENvdXJzZUJ5SWQ6IENvdXJzZSAke2lkfSBub3QgZm91bmRgKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg4pyFIGdldENvdXJzZUJ5SWQ6IEZvdW5kIGNvdXJzZSAke2lkfWApXG4gICAgcmV0dXJuIHRyYW5zZm9ybUNvdXJzZShkYXRhKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VCeUlkIEVYQ0VQVElPTjonLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyBmZWF0dXJlZCBjb3Vyc2VzIC0gZGlyZWN0bHkgcXVlcmllcyBkYXRhYmFzZSB3aXRoIGlzX2ZlYXR1cmVkIGZpbHRlclxuICogVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGZldGNoaW5nIGFsbCBjb3Vyc2VzIGFuZCBmaWx0ZXJpbmcgaW4gbWVtb3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRGZWF0dXJlZENvdXJzZXMoKTogUHJvbWlzZTxDb3Vyc2VbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfirZAgZ2V0RmVhdHVyZWRDb3Vyc2VzOiBGZXRjaGluZyBmZWF0dXJlZCBjb3Vyc2VzIGZyb20gZGF0YWJhc2UuLi4nKVxuICAgIFxuICAgIC8vIFF1ZXJ5IGRhdGFiYXNlIGRpcmVjdGx5IGZvciBmZWF0dXJlZCBjb3Vyc2VzXG4gICAgLy8gT25seSBzaG93IGNvdXJzZXMgd2hlcmUgc2lnbnVwX2VuYWJsZWQgaXMgdHJ1ZSAodmlzaWJsZSBjb3Vyc2VzKVxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnaXNfZmVhdHVyZWQnLCB0cnVlKVxuICAgICAgLmVxKCdzaWdudXBfZW5hYmxlZCcsIHRydWUpXG4gICAgICAub3JkZXIoJ3ByaW9yaXR5JywgeyBhc2NlbmRpbmc6IHRydWUsIG51bGxzRmlyc3Q6IGZhbHNlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRGZWF0dXJlZENvdXJzZXMgREFUQUJBU0UgRVJST1I6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfirZAgZ2V0RmVhdHVyZWRDb3Vyc2VzOiBObyBmZWF0dXJlZCBjb3Vyc2VzIGZvdW5kJylcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDirZAgZ2V0RmVhdHVyZWRDb3Vyc2VzOiBEYXRhYmFzZSByZXR1cm5lZCAke2RhdGEubGVuZ3RofSBmZWF0dXJlZCBjb3Vyc2VzYClcbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gZGF0YWJhc2Ugcm93cyB0byBDb3Vyc2Ugb2JqZWN0c1xuICAgIGNvbnN0IGZlYXR1cmVkID0gZGF0YS5tYXAodHJhbnNmb3JtQ291cnNlKVxuXG4gICAgY29uc29sZS5sb2coYOKtkCBnZXRGZWF0dXJlZENvdXJzZXM6IFN1Y2Nlc3NmdWxseSByZXR1cm5lZCAke2ZlYXR1cmVkLmxlbmd0aH0gZmVhdHVyZWQgY291cnNlc2ApXG4gICAgcmV0dXJuIGZlYXR1cmVkXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldEZlYXR1cmVkQ291cnNlcyBFUlJPUjonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuIl0sIm5hbWVzIjpbInN1cGFiYXNlIiwidHJhbnNmb3JtQ291cnNlIiwicm93IiwiY291cnNlVHlwZSIsInR5cGUiLCJjb3Vyc2VfdHlwZSIsImlkIiwiU3RyaW5nIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImhlYWRsaW5lIiwiYnVsbGV0X3BvaW50cyIsIkFycmF5IiwiaXNBcnJheSIsInByb3ZpZGVyIiwibGV2ZWwiLCJkdXJhdGlvbiIsInRhZ3MiLCJ0YWciLCJleHRlcm5hbF91cmwiLCJwcmlvcml0eSIsIk51bWJlciIsInJhdGluZyIsInJldmlld3MiLCJrZXlfc2tpbGxzIiwibW9kdWxlcyIsImluc3RydWN0b3JzIiwiZWZmb3J0IiwibGFuZ3VhZ2VzIiwicHJpY2UiLCJmcmVlX3RyaWFsIiwidW5kZWZpbmVkIiwic291cmNlIiwic2lnbnVwX2VuYWJsZWQiLCJCb29sZWFuIiwiaXNfZmVhdHVyZWQiLCJwcmljZV9sYWJlbCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwicmF3UXVlcnlBbGxDb3Vyc2VzIiwiY29uc29sZSIsImxvZyIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1YnN0cmluZyIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiZGF0YSIsImVycm9yIiwiY291bnQiLCJmcm9tIiwic2VsZWN0IiwibGltaXQiLCJjb2RlIiwibWVzc2FnZSIsImhpbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwid2FybiIsInN0YWNrIiwidGVzdFN1cGFiYXNlQ29ubmVjdGlvbiIsImNvdXJzZXMiLCJzYW1wbGUiLCJnZXRBbGxDb3Vyc2VzIiwicmF3Q291cnNlcyIsInRyYW5zZm9ybWVkIiwibWFwIiwiZ2V0UmVsZXZhbmN5Q29sdW1uIiwiZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwiLCJvcHRpb25zIiwiaW5jbHVkZUhpZGRlbiIsInJlbGV2YW5jeUNvbHVtbiIsInF1ZXJ5IiwiZXEiLCJvcmRlciIsImFzY2VuZGluZyIsIm51bGxzTGFzdCIsImZhbGxiYWNrUXVlcnkiLCJmYWxsYmFja0RhdGEiLCJmYWxsYmFja0Vycm9yIiwic2xpY2UiLCJnZXRDb3Vyc2VzQnlUYWciLCJnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5IiwiY291cnNlc1dpdGhSZWxldmFuY3kiLCJidXNpbmVzc19yZWxldmFuY3kiLCJyZXN0YXVyYW50X3JlbGV2YW5jeSIsImZsZWV0X3JlbGV2YW5jeSIsInJlc3VsdCIsImdldENvdXJzZXNCeVRhZ0Zvck1hbmFnZW1lbnQiLCJnZXRDb3Vyc2VCeUlkIiwibWF5YmVTaW5nbGUiLCJnZXRGZWF0dXJlZENvdXJzZXMiLCJudWxsc0ZpcnN0IiwiZmVhdHVyZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/courses.ts\n"));

/***/ })

});