"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/courses/restaurant/page",{

/***/ "(app-pages-browser)/./src/data/courses.ts":
/*!*****************************!*\
  !*** ./src/data/courses.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getCourseById: function() { return /* binding */ getCourseById; },\n/* harmony export */   getCoursesByTag: function() { return /* binding */ getCoursesByTag; },\n/* harmony export */   getCoursesByTagForManagement: function() { return /* binding */ getCoursesByTagForManagement; },\n/* harmony export */   getCoursesByTagWithRelevancy: function() { return /* binding */ getCoursesByTagWithRelevancy; },\n/* harmony export */   getFeaturedCourses: function() { return /* binding */ getFeaturedCourses; },\n/* harmony export */   getRelevancyColumn: function() { return /* binding */ getRelevancyColumn; },\n/* harmony export */   testSupabaseConnection: function() { return /* binding */ testSupabaseConnection; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n/**\n * Transform function - handles both 'course_type' and 'type' column names\n */ function transformCourse(row) {\n    // Handle both 'course_type' and 'type' column names\n    const courseType = row.type || row.course_type || null;\n    var _row_signup_enabled, _row_is_featured;\n    return {\n        id: String(row.id || \"\"),\n        title: String(row.title || \"\"),\n        description: String(row.description || \"\"),\n        headline: row.headline || null,\n        bullet_points: Array.isArray(row.bullet_points) ? row.bullet_points : null,\n        provider: row.provider || null,\n        level: row.level || \"Beginner\",\n        duration: String(row.duration || \"\"),\n        tags: row.tag ? [\n            row.tag\n        ] : [],\n        external_url: row.external_url || null,\n        priority: Number(row.priority) || 999,\n        rating: row.rating ? Number(row.rating) : null,\n        reviews: row.reviews ? Number(row.reviews) : null,\n        course_type: courseType,\n        key_skills: row.key_skills || null,\n        modules: row.modules || null,\n        instructors: row.instructors || null,\n        effort: row.effort || null,\n        languages: row.languages || null,\n        price: row.free_trial || undefined,\n        source: String(row.source || \"\"),\n        signup_enabled: Boolean((_row_signup_enabled = row.signup_enabled) !== null && _row_signup_enabled !== void 0 ? _row_signup_enabled : true),\n        is_featured: Boolean((_row_is_featured = row.is_featured) !== null && _row_is_featured !== void 0 ? _row_is_featured : false),\n        price_label: row.price_label || null,\n        free_trial: row.free_trial || null,\n        created_at: row.created_at || null,\n        updated_at: row.updated_at || null\n    };\n}\n/**\n * Raw query - just get everything, no filters\n */ async function rawQueryAllCourses() {\n    try {\n        console.log(\"\\uD83D\\uDD0D RAW QUERY: Fetching ALL courses with no filters...\");\n        // Log the Supabase URL being used (first 30 chars for security)\n        const supabaseUrl = \"https://ktqjebihzkbhsvbqpbui.supabase.co\" || 0;\n        console.log(\"\\uD83D\\uDD17 Supabase URL:\", supabaseUrl ? supabaseUrl.substring(0, 30) + \"...\" : \"❌ MISSING\");\n        console.log(\"\\uD83D\\uDD11 Anon Key:\",  true ? \"✅ Set\" : 0);\n        // Try the simplest possible query first\n        const { data, error, count } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\", {\n            count: \"exact\"\n        }).limit(100) // Add explicit limit\n        ;\n        if (error) {\n            var _error_message, _error_message1;\n            console.error(\"❌ RAW QUERY ERROR:\", error);\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            console.error(\"Error hint:\", error.hint);\n            console.error(\"Full error:\", JSON.stringify(error, null, 2));\n            // If it's an RLS error, provide helpful message\n            if (error.code === \"PGRST301\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"permission\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"policy\"))) {\n                console.error(\"\\uD83D\\uDD12 RLS ERROR: Row Level Security is blocking the query!\");\n                console.error(\"Check your Supabase RLS policies for the courses table.\");\n                console.error(\"Go to Supabase Dashboard → Authentication → Policies → courses table\");\n                console.error('Make sure \"courses_select_public\" policy exists and allows SELECT');\n            }\n            return [];\n        }\n        console.log(\"✅ RAW QUERY SUCCESS: Found \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses (count: \").concat(count, \")\"));\n        if (data && data.length > 0) {\n            console.log(\"\\uD83D\\uDCCB Sample raw course data:\", JSON.stringify(data[0], null, 2));\n            console.log(\"\\uD83D\\uDCCB All column names:\", Object.keys(data[0]));\n            console.log(\"\\uD83D\\uDCCB Sample tag value:\", data[0].tag);\n            console.log(\"\\uD83D\\uDCCB Sample priority value:\", data[0].priority);\n        } else {\n            console.warn(\"⚠️ No courses found in database\");\n            console.warn(\"This could mean:\");\n            console.warn(\"1. No courses exist in THIS Supabase project\");\n            console.warn(\"2. RLS policies are blocking the query (but no error shown)\");\n            console.warn(\"3. Wrong Supabase project/credentials\");\n            console.warn(\"\");\n            console.warn(\"\\uD83D\\uDD0D VERIFICATION STEPS:\");\n            console.warn(\"1. Go to Supabase Dashboard → Table Editor → courses\");\n            console.warn(\"2. Check if courses exist there\");\n            console.warn(\"3. Verify the Supabase URL matches:\", supabaseUrl.substring(0, 30) + \"...\");\n            console.warn(\"4. Check RLS policies: Dashboard → Authentication → Policies\");\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"❌ RAW QUERY EXCEPTION:\", error);\n        console.error(\"Exception message:\", error === null || error === void 0 ? void 0 : error.message);\n        console.error(\"Exception stack:\", error === null || error === void 0 ? void 0 : error.stack);\n        return [];\n    }\n}\n/**\n * Test Supabase connection with raw query\n */ async function testSupabaseConnection() {\n    console.log(\"\\uD83E\\uDDEA === TESTING SUPABASE CONNECTION ===\");\n    console.log(\"Supabase URL:\",  true ? \"✅ Set\" : 0);\n    console.log(\"Supabase Key:\",  true ? \"✅ Set\" : 0);\n    const courses = await rawQueryAllCourses();\n    console.log(\"\\uD83D\\uDCCA Connection test result: \".concat(courses.length, \" courses found\"));\n    if (courses.length > 0) {\n        const sample = courses[0];\n        console.log(\"\\uD83D\\uDCCB Sample course columns:\", Object.keys(sample));\n        console.log(\"\\uD83D\\uDCCB Sample course tag value:\", sample.tag);\n        console.log(\"\\uD83D\\uDCCB Sample course type column:\", sample.type || sample.course_type || \"NOT FOUND\");\n    }\n}\n/**\n * Fetches ALL courses - simplest possible query\n */ async function getAllCourses() {\n    try {\n        console.log(\"\\uD83D\\uDCE6 getAllCourses: Starting...\");\n        const rawCourses = await rawQueryAllCourses();\n        if (rawCourses.length === 0) {\n            console.warn(\"⚠️ getAllCourses: No courses found in database\");\n            return [];\n        }\n        console.log(\"\\uD83D\\uDCE6 getAllCourses: Transforming \".concat(rawCourses.length, \" courses...\"));\n        const transformed = rawCourses.map(transformCourse);\n        if (transformed.length > 0) {\n            console.log(\"✅ getAllCourses: Sample transformed course:\", {\n                id: transformed[0].id,\n                title: transformed[0].title,\n                tag: transformed[0].tags,\n                priority: transformed[0].priority\n            });\n        }\n        return transformed;\n    } catch (error) {\n        console.error(\"❌ getAllCourses ERROR:\", error);\n        return [];\n    }\n}\n/**\n * Helper function to get the relevancy column name for a given tag\n */ function getRelevancyColumn(tag) {\n    return tag === \"Business\" ? \"business_relevancy\" : tag === \"Restaurant\" ? \"restaurant_relevancy\" : \"fleet_relevancy\";\n}\n/**\n * Base internal function - fetches courses with flexible options\n * This is the single source of truth for course fetching logic\n * Returns courses with relevancy data preserved (even though Course type doesn't include it)\n */ async function getCoursesByTagInternal(tag) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const { includeHidden = false, limit } = options;\n        const relevancyColumn = getRelevancyColumn(tag);\n        console.log('\\uD83C\\uDFF7️ getCoursesByTagInternal: Fetching courses for tag \"'.concat(tag, '\" (includeHidden: ').concat(includeHidden, \", limit: \").concat(limit || \"none\", \")...\"));\n        console.log(\"\\uD83C\\uDFF7️ IMPORTANT: NO tag filter, NO signup_enabled filter - getting ALL courses sorted by \".concat(relevancyColumn));\n        console.log(\"\\uD83C\\uDFF7️ Ordering by: \".concat(relevancyColumn, \" (ascending, nullsLast)\"));\n        // Build query step by step - Supabase queries are chainable\n        // CRITICAL: NO FILTERING BY TAG OR signup_enabled - get ALL courses, sort by relevancy score\n        // The relevancy score determines which page the course appears on, not the tag field\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\");\n        // NO .eq('tag', tag) - we want ALL courses, not filtered by tag\n        // NO .eq('signup_enabled', true) - we want ALL courses regardless of signup_enabled\n        // Order by relevancy column (lower number = higher priority)\n        // This determines which courses appear on each page\n        query = query.order(relevancyColumn || \"priority\", {\n            ascending: true,\n            nullsLast: true\n        });\n        // Apply limit AFTER ordering to ensure we get the top N courses\n        if (limit) {\n            query = query.limit(limit);\n            console.log(\"\\uD83C\\uDFF7️ Limiting to \".concat(limit, \" courses\"));\n        }\n        const { data, error } = await query;\n        // Log the actual results to debug\n        console.log(\"\\uD83C\\uDFF7️ Query executed: returned \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" courses (limit was \").concat(limit || \"none\", \")\"));\n        if (data && data.length > 0) {\n            console.log(\"\\uD83C\\uDFF7️ Relevancy scores for returned courses:\", data.map((r)=>({\n                    id: r.id,\n                    title: r.title,\n                    [relevancyColumn]: r[relevancyColumn],\n                    signup_enabled: r.signup_enabled\n                })));\n        }\n        if (data && limit && data.length > limit) {\n            console.error(\"❌ ERROR: Query returned \".concat(data.length, \" courses but limit was \").concat(limit, \"! This should not happen.\"));\n        }\n        if (error) {\n            console.error(\"❌ getCoursesByTagInternal DATABASE ERROR:\", error);\n            console.error(\"Error code:\", error.code);\n            console.error(\"Error message:\", error.message);\n            // Fallback: try using priority if relevancy column doesn't exist\n            console.warn(\"⚠️ Falling back to priority-based ordering...\");\n            let fallbackQuery = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n            fallbackQuery = fallbackQuery.order(\"priority\", {\n                ascending: true,\n                nullsLast: true\n            });\n            if (limit) {\n                fallbackQuery = fallbackQuery.limit(limit);\n            }\n            const { data: fallbackData, error: fallbackError } = await fallbackQuery;\n            if (fallbackError) {\n                console.error(\"❌ Fallback query also failed:\", fallbackError);\n                return [];\n            }\n            const transformed = (fallbackData || []).map(transformCourse);\n            console.log(\"\\uD83C\\uDFF7️ getCoursesByTagInternal (fallback): Returned \".concat(transformed.length, \" courses\"));\n            return transformed;\n        }\n        if (!data || data.length === 0) {\n            console.warn('⚠️ getCoursesByTagInternal: No courses found for tag \"'.concat(tag, '\"'));\n            return [];\n        }\n        // Transform courses - relevancy data exists in raw rows but Course type doesn't include it\n        // The calling code can access it via type assertion if needed (CourseWithRelevancy)\n        let transformed = data.map(transformCourse);\n        // CRITICAL: Enforce limit in case database returns more than requested\n        // This ensures we NEVER return more courses than the limit\n        if (limit && transformed.length > limit) {\n            console.warn(\"⚠️ WARNING: Database returned \".concat(transformed.length, \" courses but limit is \").concat(limit, \". Truncating to \").concat(limit, \".\"));\n            transformed = transformed.slice(0, limit);\n        }\n        console.log(\"\\uD83C\\uDFF7️ getCoursesByTagInternal: Successfully returned \".concat(transformed.length, ' courses for tag \"').concat(tag, '\" (limit was ').concat(limit || \"none\", \")\"));\n        return transformed;\n    } catch (error) {\n        console.error(\"❌ getCoursesByTagInternal EXCEPTION:\", error);\n        console.error(\"Exception message:\", error === null || error === void 0 ? void 0 : error.message);\n        return [];\n    }\n}\n/**\n * For course pages - returns exactly 10 courses sorted by relevancy (no signup_enabled filter)\n */ async function getCoursesByTag(tag) {\n    return getCoursesByTagInternal(tag, {\n        includeHidden: true,\n        limit: 10\n    });\n}\n/**\n * For admin management - returns courses with relevancy data preserved\n * This ensures the management tool shows exactly what course pages display\n */ async function getCoursesByTagWithRelevancy(tag) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { includeHidden = false, limit = 10 } = options;\n    const relevancyColumn = getRelevancyColumn(tag);\n    try {\n        console.log('\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy: Fetching courses for tag \"'.concat(tag, '\" with relevancy data...'));\n        // Build query - same logic as getCoursesByTagInternal but preserve relevancy data\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n        if (!includeHidden) {\n            query = query.eq(\"signup_enabled\", true);\n        }\n        query = query.order(relevancyColumn || \"priority\", {\n            ascending: true,\n            nullsLast: true\n        });\n        if (limit) {\n            query = query.limit(limit);\n        }\n        const { data, error } = await query;\n        if (error) {\n            console.error(\"❌ getCoursesByTagWithRelevancy DATABASE ERROR:\", error);\n            // Fallback to priority-based ordering\n            let fallbackQuery = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"tag\", tag);\n            if (!includeHidden) {\n                fallbackQuery = fallbackQuery.eq(\"signup_enabled\", true);\n            }\n            fallbackQuery = fallbackQuery.order(\"priority\", {\n                ascending: true,\n                nullsLast: true\n            });\n            if (limit) {\n                fallbackQuery = fallbackQuery.limit(limit);\n            }\n            const { data: fallbackData, error: fallbackError } = await fallbackQuery;\n            if (fallbackError) {\n                console.error(\"❌ Fallback query also failed:\", fallbackError);\n                return [];\n            }\n            // Transform with relevancy data preserved\n            const coursesWithRelevancy = (fallbackData || []).map((row)=>{\n                var _row_business_relevancy, _row_restaurant_relevancy, _row_fleet_relevancy;\n                return {\n                    ...transformCourse(row),\n                    business_relevancy: (_row_business_relevancy = row.business_relevancy) !== null && _row_business_relevancy !== void 0 ? _row_business_relevancy : null,\n                    restaurant_relevancy: (_row_restaurant_relevancy = row.restaurant_relevancy) !== null && _row_restaurant_relevancy !== void 0 ? _row_restaurant_relevancy : null,\n                    fleet_relevancy: (_row_fleet_relevancy = row.fleet_relevancy) !== null && _row_fleet_relevancy !== void 0 ? _row_fleet_relevancy : null\n                };\n            });\n            // Enforce limit\n            const result = limit && coursesWithRelevancy.length > limit ? coursesWithRelevancy.slice(0, limit) : coursesWithRelevancy;\n            console.log(\"\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy (fallback): Returned \".concat(result.length, \" courses\"));\n            return result;\n        }\n        if (!data || data.length === 0) {\n            console.warn('⚠️ getCoursesByTagWithRelevancy: No courses found for tag \"'.concat(tag, '\"'));\n            return [];\n        }\n        // Transform courses and PRESERVE relevancy data from raw database rows\n        // This maintains the exact order from the database query\n        let coursesWithRelevancy = data.map((row)=>{\n            var _row_business_relevancy, _row_restaurant_relevancy, _row_fleet_relevancy;\n            return {\n                ...transformCourse(row),\n                business_relevancy: (_row_business_relevancy = row.business_relevancy) !== null && _row_business_relevancy !== void 0 ? _row_business_relevancy : null,\n                restaurant_relevancy: (_row_restaurant_relevancy = row.restaurant_relevancy) !== null && _row_restaurant_relevancy !== void 0 ? _row_restaurant_relevancy : null,\n                fleet_relevancy: (_row_fleet_relevancy = row.fleet_relevancy) !== null && _row_fleet_relevancy !== void 0 ? _row_fleet_relevancy : null\n            };\n        });\n        // Enforce limit\n        if (limit && coursesWithRelevancy.length > limit) {\n            console.warn(\"⚠️ WARNING: Database returned \".concat(coursesWithRelevancy.length, \" courses but limit is \").concat(limit, \". Truncating to \").concat(limit, \".\"));\n            coursesWithRelevancy = coursesWithRelevancy.slice(0, limit);\n        }\n        console.log(\"\\uD83C\\uDFF7️ getCoursesByTagWithRelevancy: Successfully returned \".concat(coursesWithRelevancy.length, ' courses for tag \"').concat(tag, '\"'));\n        return coursesWithRelevancy;\n    } catch (error) {\n        console.error(\"❌ getCoursesByTagWithRelevancy EXCEPTION:\", error);\n        return [];\n    }\n}\n/**\n * For admin management - returns all courses (visible + hidden) for management\n */ async function getCoursesByTagForManagement(tag) {\n    return getCoursesByTagInternal(tag, {\n        includeHidden: true,\n        limit: 100\n    });\n}\n/**\n * Fetches a single course by ID\n */ async function getCourseById(id) {\n    try {\n        console.log(\"\\uD83D\\uDD0D getCourseById: Fetching course \".concat(id, \"...\"));\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"id\", id).maybeSingle();\n        if (error) {\n            console.error(\"❌ getCourseById ERROR:\", error);\n            return null;\n        }\n        if (!data) {\n            console.warn(\"⚠️ getCourseById: Course \".concat(id, \" not found\"));\n            return null;\n        }\n        console.log(\"✅ getCourseById: Found course \".concat(id));\n        return transformCourse(data);\n    } catch (error) {\n        console.error(\"❌ getCourseById EXCEPTION:\", error);\n        return null;\n    }\n}\n/**\n * Fetches featured courses - directly queries database with is_featured filter\n * This is more efficient than fetching all courses and filtering in memory\n */ async function getFeaturedCourses() {\n    try {\n        console.log(\"⭐ getFeaturedCourses: Fetching featured courses from database...\");\n        // Query database directly for featured courses\n        // Only show courses where signup_enabled is true (visible courses)\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"courses\").select(\"*\").eq(\"is_featured\", true).eq(\"signup_enabled\", true).order(\"priority\", {\n            ascending: true,\n            nullsFirst: false\n        });\n        if (error) {\n            console.error(\"❌ getFeaturedCourses DATABASE ERROR:\", error);\n            return [];\n        }\n        if (!data || data.length === 0) {\n            console.log(\"⭐ getFeaturedCourses: No featured courses found\");\n            return [];\n        }\n        console.log(\"⭐ getFeaturedCourses: Database returned \".concat(data.length, \" featured courses\"));\n        // Transform database rows to Course objects\n        const featured = data.map(transformCourse);\n        console.log(\"⭐ getFeaturedCourses: Successfully returned \".concat(featured.length, \" featured courses\"));\n        return featured;\n    } catch (error) {\n        console.error(\"❌ getFeaturedCourses ERROR:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNyQkwsS0FBSyxDQUFDLFlBQVk7WUFBRUMsV0FBVztZQUFNbUIsWUFBWTtRQUFNO1FBRTFELElBQUlqRCxPQUFPO1lBQ1RULFFBQVFTLEtBQUssQ0FBQyx3Q0FBd0NBO1lBQ3RELE9BQU8sRUFBRTtRQUNYO1FBRUEsSUFBSSxDQUFDRCxRQUFRQSxLQUFLWSxNQUFNLEtBQUssR0FBRztZQUM5QnBCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU8sRUFBRTtRQUNYO1FBRUFELFFBQVFDLEdBQUcsQ0FBQywyQ0FBdUQsT0FBWk8sS0FBS1ksTUFBTSxFQUFDO1FBRW5FLDRDQUE0QztRQUM1QyxNQUFNdUMsV0FBV25ELEtBQUt1QixHQUFHLENBQUN0RTtRQUUxQnVDLFFBQVFDLEdBQUcsQ0FBQywrQ0FBK0QsT0FBaEIwRCxTQUFTdkMsTUFBTSxFQUFDO1FBQzNFLE9BQU91QztJQUNULEVBQUUsT0FBT2xELE9BQU87UUFDZFQsUUFBUVMsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsT0FBTyxFQUFFO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZGF0YS9jb3Vyc2VzLnRzPzdjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSdcbmltcG9ydCB7IENvdXJzZSwgQ291cnNlVGFnLCBEYXRhYmFzZUNvdXJzZSB9IGZyb20gJ0AvdHlwZXMvY291cnNlJ1xuXG4vKipcbiAqIFJhdyBkYXRhYmFzZSByb3cgdHlwZSAtIGFjY2VwdHMgYW55IGNvbHVtbiBuYW1lIHZhcmlhdGlvbnNcbiAqL1xudHlwZSBSYXdDb3Vyc2VSb3cgPSBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5cbi8qKlxuICogVHJhbnNmb3JtIGZ1bmN0aW9uIC0gaGFuZGxlcyBib3RoICdjb3Vyc2VfdHlwZScgYW5kICd0eXBlJyBjb2x1bW4gbmFtZXNcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQ291cnNlKHJvdzogUmF3Q291cnNlUm93KTogQ291cnNlIHtcbiAgLy8gSGFuZGxlIGJvdGggJ2NvdXJzZV90eXBlJyBhbmQgJ3R5cGUnIGNvbHVtbiBuYW1lc1xuICBjb25zdCBjb3Vyc2VUeXBlID0gcm93LnR5cGUgfHwgcm93LmNvdXJzZV90eXBlIHx8IG51bGxcbiAgXG4gIHJldHVybiB7XG4gICAgaWQ6IFN0cmluZyhyb3cuaWQgfHwgJycpLFxuICAgIHRpdGxlOiBTdHJpbmcocm93LnRpdGxlIHx8ICcnKSxcbiAgICBkZXNjcmlwdGlvbjogU3RyaW5nKHJvdy5kZXNjcmlwdGlvbiB8fCAnJyksXG4gICAgaGVhZGxpbmU6IHJvdy5oZWFkbGluZSB8fCBudWxsLFxuICAgIGJ1bGxldF9wb2ludHM6IEFycmF5LmlzQXJyYXkocm93LmJ1bGxldF9wb2ludHMpID8gcm93LmJ1bGxldF9wb2ludHMgOiBudWxsLFxuICAgIHByb3ZpZGVyOiByb3cucHJvdmlkZXIgfHwgbnVsbCxcbiAgICBsZXZlbDogKHJvdy5sZXZlbCBhcyBhbnkpIHx8ICdCZWdpbm5lcicsXG4gICAgZHVyYXRpb246IFN0cmluZyhyb3cuZHVyYXRpb24gfHwgJycpLFxuICAgIHRhZ3M6IHJvdy50YWcgPyBbcm93LnRhZ10gOiBbXSxcbiAgICBleHRlcm5hbF91cmw6IHJvdy5leHRlcm5hbF91cmwgfHwgbnVsbCxcbiAgICBwcmlvcml0eTogTnVtYmVyKHJvdy5wcmlvcml0eSkgfHwgOTk5LFxuICAgIHJhdGluZzogcm93LnJhdGluZyA/IE51bWJlcihyb3cucmF0aW5nKSA6IG51bGwsXG4gICAgcmV2aWV3czogcm93LnJldmlld3MgPyBOdW1iZXIocm93LnJldmlld3MpIDogbnVsbCxcbiAgICBjb3Vyc2VfdHlwZTogY291cnNlVHlwZSxcbiAgICBrZXlfc2tpbGxzOiByb3cua2V5X3NraWxscyB8fCBudWxsLFxuICAgIG1vZHVsZXM6IHJvdy5tb2R1bGVzIHx8IG51bGwsXG4gICAgaW5zdHJ1Y3RvcnM6IHJvdy5pbnN0cnVjdG9ycyB8fCBudWxsLFxuICAgIGVmZm9ydDogcm93LmVmZm9ydCB8fCBudWxsLFxuICAgIGxhbmd1YWdlczogcm93Lmxhbmd1YWdlcyB8fCBudWxsLFxuICAgIHByaWNlOiByb3cuZnJlZV90cmlhbCB8fCB1bmRlZmluZWQsXG4gICAgc291cmNlOiBTdHJpbmcocm93LnNvdXJjZSB8fCAnJyksXG4gICAgc2lnbnVwX2VuYWJsZWQ6IEJvb2xlYW4ocm93LnNpZ251cF9lbmFibGVkID8/IHRydWUpLFxuICAgIGlzX2ZlYXR1cmVkOiBCb29sZWFuKHJvdy5pc19mZWF0dXJlZCA/PyBmYWxzZSksXG4gICAgcHJpY2VfbGFiZWw6IHJvdy5wcmljZV9sYWJlbCB8fCBudWxsLFxuICAgIGZyZWVfdHJpYWw6IHJvdy5mcmVlX3RyaWFsIHx8IG51bGwsXG4gICAgY3JlYXRlZF9hdDogcm93LmNyZWF0ZWRfYXQgfHwgbnVsbCxcbiAgICB1cGRhdGVkX2F0OiByb3cudXBkYXRlZF9hdCB8fCBudWxsLFxuICB9XG59XG5cbi8qKlxuICogUmF3IHF1ZXJ5IC0ganVzdCBnZXQgZXZlcnl0aGluZywgbm8gZmlsdGVyc1xuICovXG5hc3luYyBmdW5jdGlvbiByYXdRdWVyeUFsbENvdXJzZXMoKTogUHJvbWlzZTxSYXdDb3Vyc2VSb3dbXT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIFJBVyBRVUVSWTogRmV0Y2hpbmcgQUxMIGNvdXJzZXMgd2l0aCBubyBmaWx0ZXJzLi4uJylcbiAgICBcbiAgICAvLyBMb2cgdGhlIFN1cGFiYXNlIFVSTCBiZWluZyB1c2VkIChmaXJzdCAzMCBjaGFycyBmb3Igc2VjdXJpdHkpXG4gICAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgJydcbiAgICBjb25zb2xlLmxvZygn8J+UlyBTdXBhYmFzZSBVUkw6Jywgc3VwYWJhc2VVcmwgPyBzdXBhYmFzZVVybC5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicgOiAn4p2MIE1JU1NJTkcnKVxuICAgIGNvbnNvbGUubG9nKCfwn5SRIEFub24gS2V5OicsIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZID8gJ+KchSBTZXQnIDogJ+KdjCBNSVNTSU5HJylcbiAgICBcbiAgICAvLyBUcnkgdGhlIHNpbXBsZXN0IHBvc3NpYmxlIHF1ZXJ5IGZpcnN0XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuICAgICAgLmxpbWl0KDEwMCkgLy8gQWRkIGV4cGxpY2l0IGxpbWl0XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBSQVcgUVVFUlkgRVJST1I6JywgZXJyb3IpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXG4gICAgICBjb25zb2xlLmVycm9yKCdGdWxsIGVycm9yOicsIEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSlcbiAgICAgIFxuICAgICAgLy8gSWYgaXQncyBhbiBSTFMgZXJyb3IsIHByb3ZpZGUgaGVscGZ1bCBtZXNzYWdlXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMzAxJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncGVybWlzc2lvbicpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdwb2xpY3knKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfwn5SSIFJMUyBFUlJPUjogUm93IExldmVsIFNlY3VyaXR5IGlzIGJsb2NraW5nIHRoZSBxdWVyeSEnKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdDaGVjayB5b3VyIFN1cGFiYXNlIFJMUyBwb2xpY2llcyBmb3IgdGhlIGNvdXJzZXMgdGFibGUuJylcbiAgICAgICAgY29uc29sZS5lcnJvcignR28gdG8gU3VwYWJhc2UgRGFzaGJvYXJkIOKGkiBBdXRoZW50aWNhdGlvbiDihpIgUG9saWNpZXMg4oaSIGNvdXJzZXMgdGFibGUnKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdNYWtlIHN1cmUgXCJjb3Vyc2VzX3NlbGVjdF9wdWJsaWNcIiBwb2xpY3kgZXhpc3RzIGFuZCBhbGxvd3MgU0VMRUNUJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYOKchSBSQVcgUVVFUlkgU1VDQ0VTUzogRm91bmQgJHtkYXRhPy5sZW5ndGggfHwgMH0gY291cnNlcyAoY291bnQ6ICR7Y291bnR9KWApXG4gICAgXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TiyBTYW1wbGUgcmF3IGNvdXJzZSBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGRhdGFbMF0sIG51bGwsIDIpKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4sgQWxsIGNvbHVtbiBuYW1lczonLCBPYmplY3Qua2V5cyhkYXRhWzBdKSlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIFNhbXBsZSB0YWcgdmFsdWU6JywgZGF0YVswXS50YWcpXG4gICAgICBjb25zb2xlLmxvZygn8J+TiyBTYW1wbGUgcHJpb3JpdHkgdmFsdWU6JywgZGF0YVswXS5wcmlvcml0eSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gY291cnNlcyBmb3VuZCBpbiBkYXRhYmFzZScpXG4gICAgICBjb25zb2xlLndhcm4oJ1RoaXMgY291bGQgbWVhbjonKVxuICAgICAgY29uc29sZS53YXJuKCcxLiBObyBjb3Vyc2VzIGV4aXN0IGluIFRISVMgU3VwYWJhc2UgcHJvamVjdCcpXG4gICAgICBjb25zb2xlLndhcm4oJzIuIFJMUyBwb2xpY2llcyBhcmUgYmxvY2tpbmcgdGhlIHF1ZXJ5IChidXQgbm8gZXJyb3Igc2hvd24pJylcbiAgICAgIGNvbnNvbGUud2FybignMy4gV3JvbmcgU3VwYWJhc2UgcHJvamVjdC9jcmVkZW50aWFscycpXG4gICAgICBjb25zb2xlLndhcm4oJycpXG4gICAgICBjb25zb2xlLndhcm4oJ/CflI0gVkVSSUZJQ0FUSU9OIFNURVBTOicpXG4gICAgICBjb25zb2xlLndhcm4oJzEuIEdvIHRvIFN1cGFiYXNlIERhc2hib2FyZCDihpIgVGFibGUgRWRpdG9yIOKGkiBjb3Vyc2VzJylcbiAgICAgIGNvbnNvbGUud2FybignMi4gQ2hlY2sgaWYgY291cnNlcyBleGlzdCB0aGVyZScpXG4gICAgICBjb25zb2xlLndhcm4oJzMuIFZlcmlmeSB0aGUgU3VwYWJhc2UgVVJMIG1hdGNoZXM6Jywgc3VwYWJhc2VVcmwuc3Vic3RyaW5nKDAsIDMwKSArICcuLi4nKVxuICAgICAgY29uc29sZS53YXJuKCc0LiBDaGVjayBSTFMgcG9saWNpZXM6IERhc2hib2FyZCDihpIgQXV0aGVudGljYXRpb24g4oaSIFBvbGljaWVzJylcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIFJBVyBRVUVSWSBFWENFUFRJT046JywgZXJyb3IpXG4gICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIG1lc3NhZ2U6JywgZXJyb3I/Lm1lc3NhZ2UpXG4gICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIHN0YWNrOicsIGVycm9yPy5zdGFjaylcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vKipcbiAqIFRlc3QgU3VwYWJhc2UgY29ubmVjdGlvbiB3aXRoIHJhdyBxdWVyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFN1cGFiYXNlQ29ubmVjdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc29sZS5sb2coJ/Cfp6ogPT09IFRFU1RJTkcgU1VQQUJBU0UgQ09OTkVDVElPTiA9PT0nKVxuICBjb25zb2xlLmxvZygnU3VwYWJhc2UgVVJMOicsIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCA/ICfinIUgU2V0JyA6ICfinYwgTWlzc2luZycpXG4gIGNvbnNvbGUubG9nKCdTdXBhYmFzZSBLZXk6JywgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPyAn4pyFIFNldCcgOiAn4p2MIE1pc3NpbmcnKVxuICBcbiAgY29uc3QgY291cnNlcyA9IGF3YWl0IHJhd1F1ZXJ5QWxsQ291cnNlcygpXG4gIGNvbnNvbGUubG9nKGDwn5OKIENvbm5lY3Rpb24gdGVzdCByZXN1bHQ6ICR7Y291cnNlcy5sZW5ndGh9IGNvdXJzZXMgZm91bmRgKVxuICBcbiAgaWYgKGNvdXJzZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNhbXBsZSA9IGNvdXJzZXNbMF1cbiAgICBjb25zb2xlLmxvZygn8J+TiyBTYW1wbGUgY291cnNlIGNvbHVtbnM6JywgT2JqZWN0LmtleXMoc2FtcGxlKSlcbiAgICBjb25zb2xlLmxvZygn8J+TiyBTYW1wbGUgY291cnNlIHRhZyB2YWx1ZTonLCBzYW1wbGUudGFnKVxuICAgIGNvbnNvbGUubG9nKCfwn5OLIFNhbXBsZSBjb3Vyc2UgdHlwZSBjb2x1bW46Jywgc2FtcGxlLnR5cGUgfHwgc2FtcGxlLmNvdXJzZV90eXBlIHx8ICdOT1QgRk9VTkQnKVxuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyBBTEwgY291cnNlcyAtIHNpbXBsZXN0IHBvc3NpYmxlIHF1ZXJ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxDb3Vyc2VzKCk6IFByb21pc2U8Q291cnNlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+TpiBnZXRBbGxDb3Vyc2VzOiBTdGFydGluZy4uLicpXG4gICAgXG4gICAgY29uc3QgcmF3Q291cnNlcyA9IGF3YWl0IHJhd1F1ZXJ5QWxsQ291cnNlcygpXG4gICAgXG4gICAgaWYgKHJhd0NvdXJzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBnZXRBbGxDb3Vyc2VzOiBObyBjb3Vyc2VzIGZvdW5kIGluIGRhdGFiYXNlJylcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDwn5OmIGdldEFsbENvdXJzZXM6IFRyYW5zZm9ybWluZyAke3Jhd0NvdXJzZXMubGVuZ3RofSBjb3Vyc2VzLi4uYClcbiAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHJhd0NvdXJzZXMubWFwKHRyYW5zZm9ybUNvdXJzZSlcbiAgICBcbiAgICBpZiAodHJhbnNmb3JtZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBnZXRBbGxDb3Vyc2VzOiBTYW1wbGUgdHJhbnNmb3JtZWQgY291cnNlOicsIHtcbiAgICAgICAgaWQ6IHRyYW5zZm9ybWVkWzBdLmlkLFxuICAgICAgICB0aXRsZTogdHJhbnNmb3JtZWRbMF0udGl0bGUsXG4gICAgICAgIHRhZzogdHJhbnNmb3JtZWRbMF0udGFncyxcbiAgICAgICAgcHJpb3JpdHk6IHRyYW5zZm9ybWVkWzBdLnByaW9yaXR5LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtZWRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0QWxsQ291cnNlcyBFUlJPUjonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIHJlbGV2YW5jeSBjb2x1bW4gbmFtZSBmb3IgYSBnaXZlbiB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGV2YW5jeUNvbHVtbih0YWc6IENvdXJzZVRhZyk6IHN0cmluZyB7XG4gIHJldHVybiB0YWcgPT09ICdCdXNpbmVzcycgXG4gICAgPyAnYnVzaW5lc3NfcmVsZXZhbmN5JyBcbiAgICA6IHRhZyA9PT0gJ1Jlc3RhdXJhbnQnIFxuICAgID8gJ3Jlc3RhdXJhbnRfcmVsZXZhbmN5JyBcbiAgICA6ICdmbGVldF9yZWxldmFuY3knXG59XG5cbi8qKlxuICogQmFzZSBpbnRlcm5hbCBmdW5jdGlvbiAtIGZldGNoZXMgY291cnNlcyB3aXRoIGZsZXhpYmxlIG9wdGlvbnNcbiAqIFRoaXMgaXMgdGhlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIGNvdXJzZSBmZXRjaGluZyBsb2dpY1xuICogUmV0dXJucyBjb3Vyc2VzIHdpdGggcmVsZXZhbmN5IGRhdGEgcHJlc2VydmVkIChldmVuIHRob3VnaCBDb3Vyc2UgdHlwZSBkb2Vzbid0IGluY2x1ZGUgaXQpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZXNCeVRhZ0ludGVybmFsKFxuICB0YWc6IENvdXJzZVRhZywgXG4gIG9wdGlvbnM6IHtcbiAgICBpbmNsdWRlSGlkZGVuPzogYm9vbGVhblxuICAgIGxpbWl0PzogbnVtYmVyXG4gIH0gPSB7fVxuKTogUHJvbWlzZTxDb3Vyc2VbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgaW5jbHVkZUhpZGRlbiA9IGZhbHNlLCBsaW1pdCB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJlbGV2YW5jeUNvbHVtbiA9IGdldFJlbGV2YW5jeUNvbHVtbih0YWcpXG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWw6IEZldGNoaW5nIGNvdXJzZXMgZm9yIHRhZyBcIiR7dGFnfVwiIChpbmNsdWRlSGlkZGVuOiAke2luY2x1ZGVIaWRkZW59LCBsaW1pdDogJHtsaW1pdCB8fCAnbm9uZSd9KS4uLmApXG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gSU1QT1JUQU5UOiBOTyB0YWcgZmlsdGVyLCBOTyBzaWdudXBfZW5hYmxlZCBmaWx0ZXIgLSBnZXR0aW5nIEFMTCBjb3Vyc2VzIHNvcnRlZCBieSAke3JlbGV2YW5jeUNvbHVtbn1gKVxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIE9yZGVyaW5nIGJ5OiAke3JlbGV2YW5jeUNvbHVtbn0gKGFzY2VuZGluZywgbnVsbHNMYXN0KWApXG4gICAgXG4gICAgLy8gQnVpbGQgcXVlcnkgc3RlcCBieSBzdGVwIC0gU3VwYWJhc2UgcXVlcmllcyBhcmUgY2hhaW5hYmxlXG4gICAgLy8gQ1JJVElDQUw6IE5PIEZJTFRFUklORyBCWSBUQUcgT1Igc2lnbnVwX2VuYWJsZWQgLSBnZXQgQUxMIGNvdXJzZXMsIHNvcnQgYnkgcmVsZXZhbmN5IHNjb3JlXG4gICAgLy8gVGhlIHJlbGV2YW5jeSBzY29yZSBkZXRlcm1pbmVzIHdoaWNoIHBhZ2UgdGhlIGNvdXJzZSBhcHBlYXJzIG9uLCBub3QgdGhlIHRhZyBmaWVsZFxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY291cnNlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC8vIE5PIC5lcSgndGFnJywgdGFnKSAtIHdlIHdhbnQgQUxMIGNvdXJzZXMsIG5vdCBmaWx0ZXJlZCBieSB0YWdcbiAgICAgIC8vIE5PIC5lcSgnc2lnbnVwX2VuYWJsZWQnLCB0cnVlKSAtIHdlIHdhbnQgQUxMIGNvdXJzZXMgcmVnYXJkbGVzcyBvZiBzaWdudXBfZW5hYmxlZFxuICAgIFxuICAgIC8vIE9yZGVyIGJ5IHJlbGV2YW5jeSBjb2x1bW4gKGxvd2VyIG51bWJlciA9IGhpZ2hlciBwcmlvcml0eSlcbiAgICAvLyBUaGlzIGRldGVybWluZXMgd2hpY2ggY291cnNlcyBhcHBlYXIgb24gZWFjaCBwYWdlXG4gICAgcXVlcnkgPSBxdWVyeS5vcmRlcihyZWxldmFuY3lDb2x1bW4gfHwgJ3ByaW9yaXR5JywgeyBhc2NlbmRpbmc6IHRydWUsIG51bGxzTGFzdDogdHJ1ZSB9KVxuICAgIFxuICAgIC8vIEFwcGx5IGxpbWl0IEFGVEVSIG9yZGVyaW5nIHRvIGVuc3VyZSB3ZSBnZXQgdGhlIHRvcCBOIGNvdXJzZXNcbiAgICBpZiAobGltaXQpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkubGltaXQobGltaXQpXG4gICAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBMaW1pdGluZyB0byAke2xpbWl0fSBjb3Vyc2VzYClcbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcbiAgICBcbiAgICAvLyBMb2cgdGhlIGFjdHVhbCByZXN1bHRzIHRvIGRlYnVnXG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gUXVlcnkgZXhlY3V0ZWQ6IHJldHVybmVkICR7ZGF0YT8ubGVuZ3RoIHx8IDB9IGNvdXJzZXMgKGxpbWl0IHdhcyAke2xpbWl0IHx8ICdub25lJ30pYClcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+377iPIFJlbGV2YW5jeSBzY29yZXMgZm9yIHJldHVybmVkIGNvdXJzZXM6YCwgZGF0YS5tYXAoKHI6IGFueSkgPT4gKHtcbiAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgIHRpdGxlOiByLnRpdGxlLFxuICAgICAgICBbcmVsZXZhbmN5Q29sdW1uXTogcltyZWxldmFuY3lDb2x1bW5dLFxuICAgICAgICBzaWdudXBfZW5hYmxlZDogci5zaWdudXBfZW5hYmxlZFxuICAgICAgfSkpKVxuICAgIH1cbiAgICBpZiAoZGF0YSAmJiBsaW1pdCAmJiBkYXRhLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRVJST1I6IFF1ZXJ5IHJldHVybmVkICR7ZGF0YS5sZW5ndGh9IGNvdXJzZXMgYnV0IGxpbWl0IHdhcyAke2xpbWl0fSEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi5gKVxuICAgIH1cbiAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCBEQVRBQkFTRSBFUlJPUjonLCBlcnJvcilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2s6IHRyeSB1c2luZyBwcmlvcml0eSBpZiByZWxldmFuY3kgY29sdW1uIGRvZXNuJ3QgZXhpc3RcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEZhbGxpbmcgYmFjayB0byBwcmlvcml0eS1iYXNlZCBvcmRlcmluZy4uLicpXG4gICAgICBsZXQgZmFsbGJhY2tRdWVyeSA9IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgICAgXG4gICAgICBmYWxsYmFja1F1ZXJ5ID0gZmFsbGJhY2tRdWVyeS5vcmRlcigncHJpb3JpdHknLCB7IGFzY2VuZGluZzogdHJ1ZSwgbnVsbHNMYXN0OiB0cnVlIH0pXG4gICAgICBcbiAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICBmYWxsYmFja1F1ZXJ5ID0gZmFsbGJhY2tRdWVyeS5saW1pdChsaW1pdClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhOiBmYWxsYmFja0RhdGEsIGVycm9yOiBmYWxsYmFja0Vycm9yIH0gPSBhd2FpdCBmYWxsYmFja1F1ZXJ5XG4gICAgICBcbiAgICAgIGlmIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWxsYmFjayBxdWVyeSBhbHNvIGZhaWxlZDonLCBmYWxsYmFja0Vycm9yKVxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSAoZmFsbGJhY2tEYXRhIHx8IFtdKS5tYXAodHJhbnNmb3JtQ291cnNlKVxuICAgICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwgKGZhbGxiYWNrKTogUmV0dXJuZWQgJHt0cmFuc2Zvcm1lZC5sZW5ndGh9IGNvdXJzZXNgKVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkXG4gICAgfVxuICAgIFxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWw6IE5vIGNvdXJzZXMgZm91bmQgZm9yIHRhZyBcIiR7dGFnfVwiYClcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gY291cnNlcyAtIHJlbGV2YW5jeSBkYXRhIGV4aXN0cyBpbiByYXcgcm93cyBidXQgQ291cnNlIHR5cGUgZG9lc24ndCBpbmNsdWRlIGl0XG4gICAgLy8gVGhlIGNhbGxpbmcgY29kZSBjYW4gYWNjZXNzIGl0IHZpYSB0eXBlIGFzc2VydGlvbiBpZiBuZWVkZWQgKENvdXJzZVdpdGhSZWxldmFuY3kpXG4gICAgbGV0IHRyYW5zZm9ybWVkID0gZGF0YS5tYXAodHJhbnNmb3JtQ291cnNlKVxuICAgIFxuICAgIC8vIENSSVRJQ0FMOiBFbmZvcmNlIGxpbWl0IGluIGNhc2UgZGF0YWJhc2UgcmV0dXJucyBtb3JlIHRoYW4gcmVxdWVzdGVkXG4gICAgLy8gVGhpcyBlbnN1cmVzIHdlIE5FVkVSIHJldHVybiBtb3JlIGNvdXJzZXMgdGhhbiB0aGUgbGltaXRcbiAgICBpZiAobGltaXQgJiYgdHJhbnNmb3JtZWQubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFdBUk5JTkc6IERhdGFiYXNlIHJldHVybmVkICR7dHJhbnNmb3JtZWQubGVuZ3RofSBjb3Vyc2VzIGJ1dCBsaW1pdCBpcyAke2xpbWl0fS4gVHJ1bmNhdGluZyB0byAke2xpbWl0fS5gKVxuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1lZC5zbGljZSgwLCBsaW1pdClcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWw6IFN1Y2Nlc3NmdWxseSByZXR1cm5lZCAke3RyYW5zZm9ybWVkLmxlbmd0aH0gY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCIgKGxpbWl0IHdhcyAke2xpbWl0IHx8ICdub25lJ30pYClcbiAgICBcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCBFWENFUFRJT046JywgZXJyb3IpXG4gICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIG1lc3NhZ2U6JywgZXJyb3I/Lm1lc3NhZ2UpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGNvdXJzZXMgd2l0aCByZWxldmFuY3kgZGF0YSAodXNlZCBieSBhZG1pbiBtYW5hZ2VtZW50KVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvdXJzZVdpdGhSZWxldmFuY3kgZXh0ZW5kcyBDb3Vyc2Uge1xuICBidXNpbmVzc19yZWxldmFuY3k/OiBudW1iZXIgfCBudWxsXG4gIHJlc3RhdXJhbnRfcmVsZXZhbmN5PzogbnVtYmVyIHwgbnVsbFxuICBmbGVldF9yZWxldmFuY3k/OiBudW1iZXIgfCBudWxsXG59XG5cbi8qKlxuICogRm9yIGNvdXJzZSBwYWdlcyAtIHJldHVybnMgZXhhY3RseSAxMCBjb3Vyc2VzIHNvcnRlZCBieSByZWxldmFuY3kgKG5vIHNpZ251cF9lbmFibGVkIGZpbHRlcilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZXNCeVRhZyh0YWc6IENvdXJzZVRhZyk6IFByb21pc2U8Q291cnNlW10+IHtcbiAgcmV0dXJuIGdldENvdXJzZXNCeVRhZ0ludGVybmFsKHRhZywgeyBpbmNsdWRlSGlkZGVuOiB0cnVlLCBsaW1pdDogMTAgfSlcbn1cblxuLyoqXG4gKiBGb3IgYWRtaW4gbWFuYWdlbWVudCAtIHJldHVybnMgY291cnNlcyB3aXRoIHJlbGV2YW5jeSBkYXRhIHByZXNlcnZlZFxuICogVGhpcyBlbnN1cmVzIHRoZSBtYW5hZ2VtZW50IHRvb2wgc2hvd3MgZXhhY3RseSB3aGF0IGNvdXJzZSBwYWdlcyBkaXNwbGF5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5KFxuICB0YWc6IENvdXJzZVRhZyxcbiAgb3B0aW9uczogeyBpbmNsdWRlSGlkZGVuPzogYm9vbGVhbjsgbGltaXQ/OiBudW1iZXIgfSA9IHt9XG4pOiBQcm9taXNlPENvdXJzZVdpdGhSZWxldmFuY3lbXT4ge1xuICBjb25zdCB7IGluY2x1ZGVIaWRkZW4gPSBmYWxzZSwgbGltaXQgPSAxMCB9ID0gb3B0aW9uc1xuICBjb25zdCByZWxldmFuY3lDb2x1bW4gPSBnZXRSZWxldmFuY3lDb2x1bW4odGFnKVxuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+Pt++4jyBnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5OiBGZXRjaGluZyBjb3Vyc2VzIGZvciB0YWcgXCIke3RhZ31cIiB3aXRoIHJlbGV2YW5jeSBkYXRhLi4uYClcbiAgICBcbiAgICAvLyBCdWlsZCBxdWVyeSAtIHNhbWUgbG9naWMgYXMgZ2V0Q291cnNlc0J5VGFnSW50ZXJuYWwgYnV0IHByZXNlcnZlIHJlbGV2YW5jeSBkYXRhXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd0YWcnLCB0YWcpXG4gICAgXG4gICAgaWYgKCFpbmNsdWRlSGlkZGVuKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdzaWdudXBfZW5hYmxlZCcsIHRydWUpXG4gICAgfVxuICAgIFxuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIocmVsZXZhbmN5Q29sdW1uIHx8ICdwcmlvcml0eScsIHsgYXNjZW5kaW5nOiB0cnVlLCBudWxsc0xhc3Q6IHRydWUgfSlcbiAgICBcbiAgICBpZiAobGltaXQpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkubGltaXQobGltaXQpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0Q291cnNlc0J5VGFnV2l0aFJlbGV2YW5jeSBEQVRBQkFTRSBFUlJPUjonLCBlcnJvcilcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHByaW9yaXR5LWJhc2VkIG9yZGVyaW5nXG4gICAgICBsZXQgZmFsbGJhY2tRdWVyeSA9IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndGFnJywgdGFnKVxuICAgICAgXG4gICAgICBpZiAoIWluY2x1ZGVIaWRkZW4pIHtcbiAgICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkuZXEoJ3NpZ251cF9lbmFibGVkJywgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkub3JkZXIoJ3ByaW9yaXR5JywgeyBhc2NlbmRpbmc6IHRydWUsIG51bGxzTGFzdDogdHJ1ZSB9KVxuICAgICAgXG4gICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgZmFsbGJhY2tRdWVyeSA9IGZhbGxiYWNrUXVlcnkubGltaXQobGltaXQpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogZmFsbGJhY2tEYXRhLCBlcnJvcjogZmFsbGJhY2tFcnJvciB9ID0gYXdhaXQgZmFsbGJhY2tRdWVyeVxuICAgICAgXG4gICAgICBpZiAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFsbGJhY2sgcXVlcnkgYWxzbyBmYWlsZWQ6JywgZmFsbGJhY2tFcnJvcilcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRyYW5zZm9ybSB3aXRoIHJlbGV2YW5jeSBkYXRhIHByZXNlcnZlZFxuICAgICAgY29uc3QgY291cnNlc1dpdGhSZWxldmFuY3kgPSAoZmFsbGJhY2tEYXRhIHx8IFtdKS5tYXAocm93ID0+ICh7XG4gICAgICAgIC4uLnRyYW5zZm9ybUNvdXJzZShyb3cpLFxuICAgICAgICBidXNpbmVzc19yZWxldmFuY3k6IHJvdy5idXNpbmVzc19yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgICAgcmVzdGF1cmFudF9yZWxldmFuY3k6IHJvdy5yZXN0YXVyYW50X3JlbGV2YW5jeSA/PyBudWxsLFxuICAgICAgICBmbGVldF9yZWxldmFuY3k6IHJvdy5mbGVldF9yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgIH0pKSBhcyBDb3Vyc2VXaXRoUmVsZXZhbmN5W11cbiAgICAgIFxuICAgICAgLy8gRW5mb3JjZSBsaW1pdFxuICAgICAgY29uc3QgcmVzdWx0ID0gbGltaXQgJiYgY291cnNlc1dpdGhSZWxldmFuY3kubGVuZ3RoID4gbGltaXQgXG4gICAgICAgID8gY291cnNlc1dpdGhSZWxldmFuY3kuc2xpY2UoMCwgbGltaXQpXG4gICAgICAgIDogY291cnNlc1dpdGhSZWxldmFuY3lcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYPCfj7fvuI8gZ2V0Q291cnNlc0J5VGFnV2l0aFJlbGV2YW5jeSAoZmFsbGJhY2spOiBSZXR1cm5lZCAke3Jlc3VsdC5sZW5ndGh9IGNvdXJzZXNgKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3k6IE5vIGNvdXJzZXMgZm91bmQgZm9yIHRhZyBcIiR7dGFnfVwiYClcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gY291cnNlcyBhbmQgUFJFU0VSVkUgcmVsZXZhbmN5IGRhdGEgZnJvbSByYXcgZGF0YWJhc2Ugcm93c1xuICAgIC8vIFRoaXMgbWFpbnRhaW5zIHRoZSBleGFjdCBvcmRlciBmcm9tIHRoZSBkYXRhYmFzZSBxdWVyeVxuICAgIGxldCBjb3Vyc2VzV2l0aFJlbGV2YW5jeSA9IGRhdGEubWFwKHJvdyA9PiAoe1xuICAgICAgLi4udHJhbnNmb3JtQ291cnNlKHJvdyksXG4gICAgICBidXNpbmVzc19yZWxldmFuY3k6IHJvdy5idXNpbmVzc19yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgIHJlc3RhdXJhbnRfcmVsZXZhbmN5OiByb3cucmVzdGF1cmFudF9yZWxldmFuY3kgPz8gbnVsbCxcbiAgICAgIGZsZWV0X3JlbGV2YW5jeTogcm93LmZsZWV0X3JlbGV2YW5jeSA/PyBudWxsLFxuICAgIH0pKSBhcyBDb3Vyc2VXaXRoUmVsZXZhbmN5W11cbiAgICBcbiAgICAvLyBFbmZvcmNlIGxpbWl0XG4gICAgaWYgKGxpbWl0ICYmIGNvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBXQVJOSU5HOiBEYXRhYmFzZSByZXR1cm5lZCAke2NvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aH0gY291cnNlcyBidXQgbGltaXQgaXMgJHtsaW1pdH0uIFRydW5jYXRpbmcgdG8gJHtsaW1pdH0uYClcbiAgICAgIGNvdXJzZXNXaXRoUmVsZXZhbmN5ID0gY291cnNlc1dpdGhSZWxldmFuY3kuc2xpY2UoMCwgbGltaXQpXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn4+377iPIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3k6IFN1Y2Nlc3NmdWxseSByZXR1cm5lZCAke2NvdXJzZXNXaXRoUmVsZXZhbmN5Lmxlbmd0aH0gY291cnNlcyBmb3IgdGFnIFwiJHt0YWd9XCJgKVxuICAgIHJldHVybiBjb3Vyc2VzV2l0aFJlbGV2YW5jeVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZXNCeVRhZ1dpdGhSZWxldmFuY3kgRVhDRVBUSU9OOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8qKlxuICogRm9yIGFkbWluIG1hbmFnZW1lbnQgLSByZXR1cm5zIGFsbCBjb3Vyc2VzICh2aXNpYmxlICsgaGlkZGVuKSBmb3IgbWFuYWdlbWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlc0J5VGFnRm9yTWFuYWdlbWVudCh0YWc6IENvdXJzZVRhZyk6IFByb21pc2U8Q291cnNlW10+IHtcbiAgcmV0dXJuIGdldENvdXJzZXNCeVRhZ0ludGVybmFsKHRhZywgeyBpbmNsdWRlSGlkZGVuOiB0cnVlLCBsaW1pdDogMTAwIH0pXG59XG5cbi8qKlxuICogRmV0Y2hlcyBhIHNpbmdsZSBjb3Vyc2UgYnkgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8Q291cnNlIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGDwn5SNIGdldENvdXJzZUJ5SWQ6IEZldGNoaW5nIGNvdXJzZSAke2lkfS4uLmApXG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLm1heWJlU2luZ2xlKClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZUJ5SWQgRVJST1I6JywgZXJyb3IpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmICghZGF0YSkge1xuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gZ2V0Q291cnNlQnlJZDogQ291cnNlICR7aWR9IG5vdCBmb3VuZGApXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDinIUgZ2V0Q291cnNlQnlJZDogRm91bmQgY291cnNlICR7aWR9YClcbiAgICByZXR1cm4gdHJhbnNmb3JtQ291cnNlKGRhdGEpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIGdldENvdXJzZUJ5SWQgRVhDRVBUSU9OOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIGZlYXR1cmVkIGNvdXJzZXMgLSBkaXJlY3RseSBxdWVyaWVzIGRhdGFiYXNlIHdpdGggaXNfZmVhdHVyZWQgZmlsdGVyXG4gKiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gZmV0Y2hpbmcgYWxsIGNvdXJzZXMgYW5kIGZpbHRlcmluZyBpbiBtZW1vcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZlYXR1cmVkQ291cnNlcygpOiBQcm9taXNlPENvdXJzZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ+KtkCBnZXRGZWF0dXJlZENvdXJzZXM6IEZldGNoaW5nIGZlYXR1cmVkIGNvdXJzZXMgZnJvbSBkYXRhYmFzZS4uLicpXG4gICAgXG4gICAgLy8gUXVlcnkgZGF0YWJhc2UgZGlyZWN0bHkgZm9yIGZlYXR1cmVkIGNvdXJzZXNcbiAgICAvLyBPbmx5IHNob3cgY291cnNlcyB3aGVyZSBzaWdudXBfZW5hYmxlZCBpcyB0cnVlICh2aXNpYmxlIGNvdXJzZXMpXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjb3Vyc2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpc19mZWF0dXJlZCcsIHRydWUpXG4gICAgICAuZXEoJ3NpZ251cF9lbmFibGVkJywgdHJ1ZSlcbiAgICAgIC5vcmRlcigncHJpb3JpdHknLCB7IGFzY2VuZGluZzogdHJ1ZSwgbnVsbHNGaXJzdDogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldEZlYXR1cmVkQ291cnNlcyBEQVRBQkFTRSBFUlJPUjonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ+KtkCBnZXRGZWF0dXJlZENvdXJzZXM6IE5vIGZlYXR1cmVkIGNvdXJzZXMgZm91bmQnKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYOKtkCBnZXRGZWF0dXJlZENvdXJzZXM6IERhdGFiYXNlIHJldHVybmVkICR7ZGF0YS5sZW5ndGh9IGZlYXR1cmVkIGNvdXJzZXNgKVxuICAgIFxuICAgIC8vIFRyYW5zZm9ybSBkYXRhYmFzZSByb3dzIHRvIENvdXJzZSBvYmplY3RzXG4gICAgY29uc3QgZmVhdHVyZWQgPSBkYXRhLm1hcCh0cmFuc2Zvcm1Db3Vyc2UpXG5cbiAgICBjb25zb2xlLmxvZyhg4q2QIGdldEZlYXR1cmVkQ291cnNlczogU3VjY2Vzc2Z1bGx5IHJldHVybmVkICR7ZmVhdHVyZWQubGVuZ3RofSBmZWF0dXJlZCBjb3Vyc2VzYClcbiAgICByZXR1cm4gZmVhdHVyZWRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0RmVhdHVyZWRDb3Vyc2VzIEVSUk9SOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJ0cmFuc2Zvcm1Db3Vyc2UiLCJyb3ciLCJjb3Vyc2VUeXBlIiwidHlwZSIsImNvdXJzZV90eXBlIiwiaWQiLCJTdHJpbmciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiaGVhZGxpbmUiLCJidWxsZXRfcG9pbnRzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvdmlkZXIiLCJsZXZlbCIsImR1cmF0aW9uIiwidGFncyIsInRhZyIsImV4dGVybmFsX3VybCIsInByaW9yaXR5IiwiTnVtYmVyIiwicmF0aW5nIiwicmV2aWV3cyIsImtleV9za2lsbHMiLCJtb2R1bGVzIiwiaW5zdHJ1Y3RvcnMiLCJlZmZvcnQiLCJsYW5ndWFnZXMiLCJwcmljZSIsImZyZWVfdHJpYWwiLCJ1bmRlZmluZWQiLCJzb3VyY2UiLCJzaWdudXBfZW5hYmxlZCIsIkJvb2xlYW4iLCJpc19mZWF0dXJlZCIsInByaWNlX2xhYmVsIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJyYXdRdWVyeUFsbENvdXJzZXMiLCJjb25zb2xlIiwibG9nIiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3Vic3RyaW5nIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJkYXRhIiwiZXJyb3IiLCJjb3VudCIsImZyb20iLCJzZWxlY3QiLCJsaW1pdCIsImNvZGUiLCJtZXNzYWdlIiwiaGludCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbmNsdWRlcyIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJ3YXJuIiwic3RhY2siLCJ0ZXN0U3VwYWJhc2VDb25uZWN0aW9uIiwiY291cnNlcyIsInNhbXBsZSIsImdldEFsbENvdXJzZXMiLCJyYXdDb3Vyc2VzIiwidHJhbnNmb3JtZWQiLCJtYXAiLCJnZXRSZWxldmFuY3lDb2x1bW4iLCJnZXRDb3Vyc2VzQnlUYWdJbnRlcm5hbCIsIm9wdGlvbnMiLCJpbmNsdWRlSGlkZGVuIiwicmVsZXZhbmN5Q29sdW1uIiwicXVlcnkiLCJvcmRlciIsImFzY2VuZGluZyIsIm51bGxzTGFzdCIsInIiLCJmYWxsYmFja1F1ZXJ5IiwiZXEiLCJmYWxsYmFja0RhdGEiLCJmYWxsYmFja0Vycm9yIiwic2xpY2UiLCJnZXRDb3Vyc2VzQnlUYWciLCJnZXRDb3Vyc2VzQnlUYWdXaXRoUmVsZXZhbmN5IiwiY291cnNlc1dpdGhSZWxldmFuY3kiLCJidXNpbmVzc19yZWxldmFuY3kiLCJyZXN0YXVyYW50X3JlbGV2YW5jeSIsImZsZWV0X3JlbGV2YW5jeSIsInJlc3VsdCIsImdldENvdXJzZXNCeVRhZ0Zvck1hbmFnZW1lbnQiLCJnZXRDb3Vyc2VCeUlkIiwibWF5YmVTaW5nbGUiLCJnZXRGZWF0dXJlZENvdXJzZXMiLCJudWxsc0ZpcnN0IiwiZmVhdHVyZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/courses.ts\n"));

/***/ })

});